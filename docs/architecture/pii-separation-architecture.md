# PII/Non-PII Separation Architecture Design Document

## Table of Contents

1. [Background and Motivation](#1-background-and-motivation)
2. [Current State Analysis](#2-current-state-analysis)
3. [Design Principles](#3-design-principles)
4. [Architecture Overview](#4-architecture-overview)
5. [Layer Design](#5-layer-design)
6. [Improvement Details](#6-improvement-details)
7. [Implementation Plan](#7-implementation-plan)
8. [Future Extensibility](#8-future-extensibility)

---

## 1. Background and Motivation

### 1.1 Origin: WebAuthn user_handle PII Verification

The WebAuthn specification allows `user_handle` (user identifier stored in the authenticator) to be "any byte sequence". If the following are included, it becomes PII (Personally Identifiable Information) and subject to regulations such as GDPR:

- Email address
- Internal ID (guessable formats like `user12345`)

**Verification Results of Current Authrim Implementation:**

```typescript
// packages/op-auth/src/passkey.ts:179
userID: encoder.encode(user.id as string); // user.id is a UUID

// packages/op-auth/src/passkey.ts:129
const newUserId = crypto.randomUUID(); // Generated with UUID v4
```

**Conclusion**: `user_handle` uses a UUID generated by `crypto.randomUUID()`, and **does not contain PII**. This is a correct implementation.

### 1.2 Broader Issue: PII Scattered Throughout the System

Using the WebAuthn verification as a starting point, an investigation of PII distribution across the entire system revealed the following issues:

1. **Database**: Tables containing PII and those without PII are mixed in the same D1 instance
2. **Cache**: Complete user profiles (PII) are stored in the `USER_CACHE` KV
3. **Regional Requirements**: Regulations such as GDPR (EU) and APPI (Japan) require PII to be stored within specific regions
4. **Lack of Separation**: No mechanism to restrict direct PII access from application code

### 1.3 Design Goals

1. **Physical Separation of PII and Non-PII**: Place in different databases/storage
2. **Regional Compliance**: Enable storing PII in region-specific databases
3. **Abstraction**: Make database backends interchangeable (D1, Postgres, DynamoDB, etc.)
4. **Type Safety**: Control PII access through TypeScript's type system
5. **Beyond Auth0/Okta**: Differentiation through built-in ReBAC + PII separation

---

## 2. Current State Analysis

### 2.1 Token PII Analysis

#### Access Token

```typescript
// packages/op-token/src/token.ts:862-885
const accessTokenClaims = {
  iss: c.env.ISSUER_URL,        // âœ… Non-PII
  sub: authCodeData.sub,         // âœ… UUID (Non-PII)
  aud: c.env.ISSUER_URL,        // âœ… Non-PII
  scope: authCodeData.scope,     // âœ… Non-PII
  client_id: client_id,          // âœ… Non-PII
  // RBAC Claims
  authrim_roles: [...],          // âœ… Non-PII
  authrim_org_id: "...",         // âœ… UUID (Non-PII)
  authrim_org_type: "...",       // âœ… Non-PII
};
```

**Conclusion**: Access Token contains no PII. `sub` is a UUID, and email/name are only obtained via the UserInfo endpoint.

#### ID Token

```typescript
// packages/op-token/src/token.ts:938-949
const idTokenClaims = {
  iss,
  sub,
  aud,
  nonce,
  at_hash,
  auth_time,
  sid, // âœ… All Non-PII
  // RBAC Claims (controllable via environment variables)
  authrim_roles,
  authrim_user_type,
  authrim_org_id, // âœ… Non-PII
  authrim_org_name, // âš ï¸ Quasi-PII (company name) - not included by default
  authrim_orgs, // âš ï¸ Quasi-PII (contains org names) - not included by default
};
```

**Conclusion**: ID Token also basically contains no PII. `org_name` is controllable via `RBAC_ID_TOKEN_CLAIMS` environment variable (default: not included).

#### Refresh Token

```typescript
// packages/op-token/src/token.ts:1057-1063
const refreshTokenClaims = {
  iss,
  sub,
  aud,
  scope,
  client_id, // âœ… All Non-PII
};
```

**Conclusion**: Refresh Token contains no PII.

### 2.2 Database Table PII Classification

#### Tables Containing PII (Require Separation)

| Table Name            | PII Fields                                                                                                                                                               | Risk Level   |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------ |
| `users`               | email, name, given_name, family_name, middle_name, nickname, preferred_username, phone_number, address_json, birthdate, gender, picture, profile, website, password_hash | **Critical** |
| `user_custom_fields`  | field_value (may contain arbitrary PII)                                                                                                                                  | **High**     |
| `subject_identifiers` | identifier_value (email, phone, DID, etc.)                                                                                                                               | **High**     |
| `verified_attributes` | attribute_value (medical license numbers, etc.)                                                                                                                          | **High**     |
| `linked_identities`   | provider_email, raw_claims, profile_data                                                                                                                                 | **High**     |
| `audit_log`           | ip_address, user_agent                                                                                                                                                   | **Medium**   |

#### Non-PII Tables (No Separation Required)

| Category              | Table Name                  | Description                          |
| --------------------- | --------------------------- | ------------------------------------ |
| **Auth Infra**        | passkeys                    | Public keys, credential_id (UUID ref)|
|                       | sessions                    | Session ID (UUID reference)          |
|                       | password_reset_tokens       | Token hash only                      |
|                       | user_token_families         | JTI, UUID reference                  |
|                       | external_idp_auth_states    | OAuth state, PKCE verifier           |
| **Authz/RBAC**        | roles                       | Role definitions                     |
|                       | user_roles                  | UUID references only                 |
|                       | role_assignments            | UUID references only                 |
|                       | organizations               | Org name (â€»quasi-PII, needs review) |
|                       | subject_org_membership      | UUID references only                 |
|                       | relationships               | ReBAC relationships (UUID ref)       |
|                       | relation_definitions        | Relation definitions                 |
|                       | relationship_closure        | Transitive closure                   |
| **Config/Master**     | oauth_clients               | Client configuration                 |
|                       | oauth_client_consents       | UUID references only                 |
|                       | upstream_providers          | IdP configuration                    |
|                       | scope_mappings              | Scope definitions                    |
|                       | branding_settings           | UI settings                          |
|                       | identity_providers          | IdP configuration                    |
|                       | refresh_token_shard_configs | Sharding configuration               |

### 2.3 KV Cache PII Classification

| KV Namespace   | PII                                            | Separation Target |
| -------------- | ---------------------------------------------- | ----------------- |
| **USER_CACHE** | âœ… Full profile (email, name, phone, etc.)    | ğŸ”´ Required       |
| CONSENT_CACHE  | âŒ scope, granted_at only                     | âœ… Not required   |
| STATE_STORE    | âŒ state â†’ client_id                          | âœ… Not required   |
| NONCE_STORE    | âŒ nonce â†’ client_id                          | âœ… Not required   |
| CLIENTS_CACHE  | âŒ Client configuration                       | âœ… Not required   |
| REBAC_CACHE    | âŒ Roles, permissions                         | âœ… Not required   |

---

## 3. Design Principles

### 3.1 Three-tier Repository Pattern

Repositories are divided into the following 3 tiers:

| Tier                | Characteristics                     | Use Case                                     |
| ------------------- | ----------------------------------- | -------------------------------------------- |
| **CacheRepository** | Fastest, volatile, cheap            | UserInfo acceleration, RBAC claim caching    |
| **CoreRepository**  | Durable, consistent, global         | Source of truth for auth & authz             |
| **PIIRepository**   | Regional, GDPR-compliant, encrypted | Personal information only                    |

**Design Philosophy**:

- Cache tier is "fastest, cheapest, volatile" â€” can be rebuilt if lost
- Core tier is "durable, unique, consistent" â€” foundation of authentication
- PII tier is "regionally bound, recoverable" â€” addresses legal requirements

### 3.2 Prohibit Direct PII Access from Application Layer

Clearly restrict which Repository each endpoint can access:

| Endpoint       | Core | Cache | PII |
| -------------- | ---- | ----- | --- |
| `/authorize`   | âœ…   | âœ…    | âŒ  |
| `/token`       | âœ…   | âœ…    | âŒ  |
| `/userinfo`    | âœ…   | âœ…    | âœ…  |
| `/signup`      | âœ…   | âŒ    | âœ…  |
| `/admin/users` | âœ…   | âœ…    | âœ…  |

**Design Philosophy**: Authentication/authorization flows (`/authorize`, `/token`) do not require PII. PII is only needed for `/userinfo` and user management APIs. This rule is enforced at the TypeScript type level.

### 3.3 Database Adapter Abstraction

Abstract database access to ensure future portability:

| Cloudflare      | AWS Equivalent                      |
| --------------- | ----------------------------------- |
| D1              | Aurora Serverless / DynamoDB        |
| Durable Objects | DynamoDB + Item Locking             |
| KV              | ElastiCache / DynamoDB              |
| Workers         | Lambda@Edge                         |

**Design Philosophy**: Authrim aims to "surpass Auth0". Infrastructure-agnostic design enables operation on both Cloudflare and AWS.

### 3.4 ReBAC and Durable Objects Compatibility

ReBAC (Relationship-Based Access Control) is highly compatible with Durable Objects:

- **Single-thread consistency model**: DO characteristics align with "graph consistency"
- **Fast append-only**: Relationship additions are fast
- **Shard by tenant_id or group_id**: Easy per-tenant sharding
- **ReBAC evaluation can be instant with KV/D1 alone**

**Differentiation Point**: Auth0 and Okta don't have built-in ReBAC and require external services (OpenFGA, etc.). Authrim differentiates by building in ReBAC.

---

## 4. Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Application Layer                         â”‚
â”‚               (Hono handlers, services, flows)                 â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚  â”‚ /authorize  â”‚ â”‚ /token      â”‚ â”‚ /userinfo   â”‚              â”‚
â”‚  â”‚ Core+Cache  â”‚ â”‚ Core+Cache  â”‚ â”‚ Core+Cache  â”‚              â”‚
â”‚  â”‚ only        â”‚ â”‚ only        â”‚ â”‚ +PII        â”‚              â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Repository Layer                         â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  CoreRepository  â”‚ â”‚  PIIRepository   â”‚ â”‚ CacheRepositoryâ”‚ â”‚
â”‚  â”‚                  â”‚ â”‚                  â”‚ â”‚                â”‚ â”‚
â”‚  â”‚ â€¢ UserCore       â”‚ â”‚ â€¢ UserProfile    â”‚ â”‚ â€¢ UserCache    â”‚ â”‚
â”‚  â”‚ â€¢ Passkey        â”‚ â”‚ â€¢ Identifiers    â”‚ â”‚ â€¢ ConsentCache â”‚ â”‚
â”‚  â”‚ â€¢ Session        â”‚ â”‚ â€¢ LinkedIdentity â”‚ â”‚ â€¢ RBACCache    â”‚ â”‚
â”‚  â”‚ â€¢ Role           â”‚ â”‚ â€¢ AuditLog(PII)  â”‚ â”‚ â€¢ ClientCache  â”‚ â”‚
â”‚  â”‚ â€¢ Relationship   â”‚ â”‚                  â”‚ â”‚                â”‚ â”‚
â”‚  â”‚ â€¢ OAuthClient    â”‚ â”‚                  â”‚ â”‚                â”‚ â”‚
â”‚  â”‚ â€¢ Organization   â”‚ â”‚                  â”‚ â”‚                â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Database Adapter Layer                       â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ D1Adapter  â”‚ â”‚ DOAdapter  â”‚ â”‚ KVAdapter  â”‚ â”‚ PGAdapter  â”‚  â”‚
â”‚  â”‚            â”‚ â”‚            â”‚ â”‚            â”‚ â”‚ (Regional) â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚  Future: DynamoDBAdapter, AuroraAdapter, ElastiCacheAdapter   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â–¼               â–¼               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Global Non-PII  â”‚ â”‚  Global Cache   â”‚ â”‚  Regional PII   â”‚
â”‚     (D1/DO)     â”‚ â”‚     (KV/DO)     â”‚ â”‚   (Postgres)    â”‚
â”‚                 â”‚ â”‚                 â”‚ â”‚                 â”‚
â”‚ â€¢ users_core    â”‚ â”‚ â€¢ USER_CACHE    â”‚ â”‚ EU: users_pii   â”‚
â”‚ â€¢ passkeys      â”‚ â”‚ â€¢ REBAC_CACHE   â”‚ â”‚ JP: users_pii   â”‚
â”‚ â€¢ sessions      â”‚ â”‚ â€¢ CONSENT_CACHE â”‚ â”‚ US: users_pii   â”‚
â”‚ â€¢ roles         â”‚ â”‚ â€¢ CLIENTS_CACHE â”‚ â”‚                 â”‚
â”‚ â€¢ relationships â”‚ â”‚ â€¢ STATE_STORE   â”‚ â”‚ â€¢ identifiers   â”‚
â”‚ â€¢ oauth_clients â”‚ â”‚                 â”‚ â”‚ â€¢ linked_ids    â”‚
â”‚ â€¢ organizations â”‚ â”‚                 â”‚ â”‚ â€¢ audit_log_pii â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5. Layer Design

### 5.1 Database Adapter Layer

#### Interface Definition

```typescript
// packages/shared/src/db/adapter.ts

export interface DatabaseAdapter {
  // Query execution
  query<T>(sql: string, params?: unknown[]): Promise<T[]>;
  queryOne<T>(sql: string, params?: unknown[]): Promise<T | null>;
  execute(sql: string, params?: unknown[]): Promise<{ rowsAffected: number }>;

  // Transaction support
  transaction<T>(fn: (tx: TransactionAdapter) => Promise<T>): Promise<T>;

  // Batch operations
  batch(statements: PreparedStatement[]): Promise<void>;
}

export interface TransactionAdapter extends DatabaseAdapter {
  commit(): Promise<void>;
  rollback(): Promise<void>;
}
```

#### D1 Adapter

```typescript
// packages/shared/src/db/adapters/d1-adapter.ts

export class D1Adapter implements DatabaseAdapter {
  constructor(private db: D1Database) {}

  async query<T>(sql: string, params?: unknown[]): Promise<T[]> {
    const stmt = this.db.prepare(sql);
    if (params) stmt.bind(...params);
    const result = await stmt.all<T>();
    return result.results;
  }

  async queryOne<T>(sql: string, params?: unknown[]): Promise<T | null> {
    const stmt = this.db.prepare(sql);
    if (params) stmt.bind(...params);
    return await stmt.first<T>();
  }

  // ... other methods
}
```

#### Postgres Adapter (for Regional PII)

```typescript
// packages/shared/src/db/adapters/postgres-adapter.ts

import { Pool } from 'pg'; // or @neondatabase/serverless

export class PostgresAdapter implements DatabaseAdapter {
  constructor(private pool: Pool) {}

  async query<T>(sql: string, params?: unknown[]): Promise<T[]> {
    // Note: Postgres uses $1, $2 placeholders instead of ?
    const result = await this.pool.query(sql, params);
    return result.rows as T[];
  }

  // ... other methods
}
```

### 5.2 Repository Layer

#### CoreRepository

```typescript
// packages/shared/src/repositories/core/index.ts

export class CoreRepository {
  constructor(private db: DatabaseAdapter) {}

  // User Core (Non-PII)
  async getUserCore(userId: string): Promise<UserCore | null>;
  async createUserCore(data: CreateUserCoreInput): Promise<UserCore>;
  async updateUserCore(userId: string, data: UpdateUserCoreInput): Promise<void>;

  // Passkeys
  async getPasskeysByUserId(userId: string): Promise<Passkey[]>;
  async createPasskey(data: CreatePasskeyInput): Promise<Passkey>;

  // Sessions
  async getSession(sessionId: string): Promise<Session | null>;
  async createSession(data: CreateSessionInput): Promise<Session>;

  // Roles & Permissions
  async getUserRoles(userId: string): Promise<Role[]>;
  async assignRole(userId: string, roleId: string): Promise<void>;

  // Relationships (ReBAC)
  async getRelationships(subjectId: string): Promise<Relationship[]>;
  async createRelationship(data: CreateRelationshipInput): Promise<void>;

  // OAuth Clients
  async getClient(clientId: string): Promise<OAuthClient | null>;

  // Organizations
  async getOrganization(orgId: string): Promise<Organization | null>;
  async getUserOrganizations(userId: string): Promise<Organization[]>;
}
```

#### PIIRepository

```typescript
// packages/shared/src/repositories/pii/index.ts

export class PIIRepository {
  constructor(
    private db: DatabaseAdapter,
    private encryption: EncryptionService // Field-level encryption
  ) {}

  // User Profile (PII)
  async getUserProfile(userId: string): Promise<UserProfile | null>;
  async createUserProfile(data: CreateUserProfileInput): Promise<UserProfile>;
  async updateUserProfile(userId: string, data: UpdateUserProfileInput): Promise<void>;
  async deleteUserProfile(userId: string): Promise<void>; // GDPR deletion
  async anonymizeUserProfile(userId: string): Promise<void>; // GDPR anonymization

  // Identifiers
  async getIdentifiersByUserId(userId: string): Promise<Identifier[]>;
  async findUserByEmail(email: string): Promise<string | null>; // Returns userId via blind index

  // Linked Identities
  async getLinkedIdentities(userId: string): Promise<LinkedIdentity[]>;

  // Audit Log (PII portion)
  async createAuditLogPII(auditId: string, data: AuditLogPIIInput): Promise<void>;
}
```

#### CacheRepository

```typescript
// packages/shared/src/repositories/cache/index.ts

export class CacheRepository {
  constructor(
    private userCache: KVNamespace,
    private consentCache: KVNamespace,
    private rbacCache: KVNamespace,
    private clientsCache: KVNamespace
  ) {}

  // User Cache
  async getCachedUser(userId: string): Promise<CachedUser | null>;
  async setCachedUser(userId: string, user: CachedUser, ttl?: number): Promise<void>;
  async invalidateUser(userId: string): Promise<void>;

  // Consent Cache
  async getCachedConsent(userId: string, clientId: string): Promise<CachedConsent | null>;
  async setCachedConsent(userId: string, clientId: string, consent: CachedConsent): Promise<void>;
  async invalidateConsent(userId: string, clientId?: string): Promise<void>;

  // RBAC Cache
  async getCachedRBAC(userId: string): Promise<CompositeRBACCache | null>;
  async setCachedRBAC(userId: string, rbac: CompositeRBACCache, ttl?: number): Promise<void>;
  async invalidateRBAC(userId: string): Promise<void>;

  // Client Cache
  async getCachedClient(clientId: string): Promise<OAuthClient | null>;
  async setCachedClient(clientId: string, client: OAuthClient): Promise<void>;
  async invalidateClient(clientId: string): Promise<void>;
}
```

### 5.3 Service Layer

```typescript
// packages/shared/src/services/user.service.ts

export class UserService {
  constructor(
    private core: CoreRepository,
    private pii: PIIRepository,
    private cache: CacheRepository
  ) {}

  async getUser(userId: string): Promise<User | null> {
    // 1. Try cache first
    const cached = await this.cache.getCachedUser(userId);
    if (cached) return this.toCachedUser(cached);

    // 2. Fetch from both DBs in parallel
    const [core, profile] = await Promise.all([
      this.core.getUserCore(userId),
      this.pii.getUserProfile(userId),
    ]);

    if (!core) return null;

    const user = { ...core, ...profile };

    // 3. Populate cache
    await this.cache.setCachedUser(userId, user);

    return user;
  }

  async createUser(input: CreateUserInput): Promise<User> {
    const userId = crypto.randomUUID();

    // Core DB first (if this fails, no PII is stored)
    await this.core.createUserCore({
      id: userId,
      pii_region: input.region || 'eu',
      email_verified: false,
      user_type: 'end_user',
    });

    // Then PII DB
    await this.pii.createUserProfile({
      id: userId,
      email: input.email,
      name: input.name,
    });

    return this.getUser(userId);
  }

  async deleteUser(userId: string): Promise<void> {
    // 1. Hard delete from PII
    await this.pii.deleteUserProfile(userId);

    // 2. Soft delete in Core
    await this.core.updateUserCore(userId, { is_deleted: true });

    // 3. Invalidate cache
    await this.cache.invalidateUser(userId);
  }
}
```

### 5.4 Region Router

```typescript
// packages/shared/src/db/region-router.ts

export type Region = 'eu' | 'us' | 'jp' | 'global';

export interface RegionConfig {
  eu: string; // EU Postgres connection string
  us: string; // US Postgres connection string
  jp: string; // JP Postgres connection string
}

export class RegionRouter {
  private adapters: Map<Region, DatabaseAdapter> = new Map();

  constructor(private config: RegionConfig) {}

  async getPIIAdapter(userId: string, coreDb: DatabaseAdapter): Promise<DatabaseAdapter> {
    // Get user's region from Core DB
    const user = await coreDb.queryOne<{ pii_region: Region }>(
      'SELECT pii_region FROM users_core WHERE id = ?',
      [userId]
    );

    const region = user?.pii_region || 'eu';
    return this.getAdapter(region);
  }

  getAdapterForRegion(region: Region): DatabaseAdapter {
    return this.getAdapter(region);
  }

  private getAdapter(region: Region): DatabaseAdapter {
    if (!this.adapters.has(region)) {
      const connectionString = this.config[region];
      this.adapters.set(region, new PostgresAdapter(connectionString));
    }
    return this.adapters.get(region)!;
  }
}
```

### 5.5 Type-safe PII Access Control

```typescript
// packages/shared/src/context/types.ts

// Context that cannot access PII (for /authorize, /token)
export interface AuthContext {
  core: CoreRepository;
  cache: CacheRepository;
  // No pii property â†’ Cannot access PII
}

// Context that can access PII (for /userinfo, /admin/users)
export interface UserInfoContext extends AuthContext {
  pii: PIIRepository;
}

// Handler type definitions
export type AuthHandler = (c: HonoContext, ctx: AuthContext) => Promise<Response>;
export type UserInfoHandler = (c: HonoContext, ctx: UserInfoContext) => Promise<Response>;

// Usage example
// authorize.ts - AuthHandler, so accessing ctx.pii causes compile error
export const authorizeHandler: AuthHandler = async (c, ctx) => {
  const user = await ctx.core.getUserCore(userId); // âœ… OK
  // ctx.pii.getUserProfile(userId);  // âŒ Compile error: Property 'pii' does not exist
};

// userinfo.ts - UserInfoHandler, so ctx.pii is accessible
export const userinfoHandler: UserInfoHandler = async (c, ctx) => {
  const [core, profile] = await Promise.all([
    ctx.core.getUserCore(userId), // âœ… OK
    ctx.pii.getUserProfile(userId), // âœ… OK
  ]);
};
```

---

## 6. Improvement Details

### 6.1 PII Encryption Strategy (Field-level + TDE)

#### Overview

Implement multiple layers of encryption to protect PII:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Encryption Strategy                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Layer 1: Database-level encryption (TDE)        â”‚
â”‚          â†’ Postgres transparent encryption      â”‚
â”‚          â†’ Protection against disk loss/        â”‚
â”‚            snapshot leaks                       â”‚
â”‚                                                 â”‚
â”‚ Layer 2: Field-level encryption (AES-256-GCM)  â”‚
â”‚          â†’ Individual encryption of email,     â”‚
â”‚            phone, address                       â”‚
â”‚          â†’ Protection against DBA or           â”‚
â”‚            misconfiguration leaks               â”‚
â”‚                                                 â”‚
â”‚ Layer 3: Key Management (KMS + DEK)            â”‚
â”‚          â†’ Master Key in KMS (AWS/GCP)         â”‚
â”‚          â†’ Per-tenant DEK (Data Encryption Key)â”‚
â”‚          â†’ Workers-side keys in CF Secrets     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Blind Index (Searchable Encryption)

Implement Blind Index to enable searching encrypted fields like email:

```typescript
// Blind Index generation
function createBlindIndex(value: string, masterIndexKey: string): string {
  const normalized = value.toLowerCase().trim();
  return crypto.createHmac('sha256', masterIndexKey).update(normalized).digest('base64url');
}

// Table design
// users_pii
//   id: TEXT PRIMARY KEY
//   email_encrypted: TEXT       -- email encrypted with AES-256-GCM
//   email_blind_index: TEXT     -- HMAC(masterIndexKey, normalized_email)
//   ...
```

**Limitations**:

- Prefix and partial match searches are not possible (requires separate search store if needed)
- Only exact match searches are supported

#### Key Management Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Key Hierarchy                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ KMS (AWS KMS / GCP KMS)                         â”‚
â”‚   â””â”€â”€ Master Key (KEK: Key Encryption Key)     â”‚
â”‚         â”‚                                       â”‚
â”‚         â”œâ”€â”€ Tenant A DEK (wrapped)             â”‚
â”‚         â”œâ”€â”€ Tenant B DEK (wrapped)             â”‚
â”‚         â””â”€â”€ Tenant C DEK (wrapped)             â”‚
â”‚                                                 â”‚
â”‚ Cloudflare Secrets                              â”‚
â”‚   â””â”€â”€ Index Key (for Blind Index HMAC)         â”‚
â”‚   â””â”€â”€ Session Key (for Workers-side ops)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Operational Flow**:

1. Retrieve Tenant DEK from KMS at application startup (wrapped)
2. Unwrap DEK with KMS and hold in memory
3. Use DEK for PII encryption/decryption
4. Rotate DEK periodically (see below)

### 6.2 Audit Log Separation Design

#### Overview

Separate Audit Log into Core (non-PII) and PII layers:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Audit Log Strategy                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ audit_log_core (Global D1)                      â”‚
â”‚   â€¢ id                                          â”‚
â”‚   â€¢ action                                      â”‚
â”‚   â€¢ resource_type, resource_id                 â”‚
â”‚   â€¢ user_id (UUID only)                        â”‚
â”‚   â€¢ geo_country (country level only)           â”‚
â”‚   â€¢ timestamp                                   â”‚
â”‚   â€¢ metadata_json (non-PII only)               â”‚
â”‚                                                 â”‚
â”‚ audit_log_pii (Regional Postgres)              â”‚
â”‚   â€¢ audit_id (FK to core)                      â”‚
â”‚   â€¢ ip_address_encrypted                       â”‚
â”‚   â€¢ user_agent_hash (salted)                   â”‚
â”‚   â€¢ request_headers_encrypted (if needed)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Design Philosophy

- **Regular auditing/troubleshooting**: `audit_log_core` alone covers 80-90% of use cases
- **Legal requests/detailed investigation only**: Reference PII side
- **Privacy considerations**:
  - IP addresses are encrypted
  - User-Agent is salted hash (improved tracking resistance)
  - Geo is country-level only in Core

#### Schema

```sql
-- Global D1: audit_log_core
CREATE TABLE audit_log_core (
  id TEXT PRIMARY KEY,
  tenant_id TEXT NOT NULL DEFAULT 'default',
  user_id TEXT,  -- UUID only, no PII
  action TEXT NOT NULL,
  resource_type TEXT,
  resource_id TEXT,
  geo_country TEXT,  -- Country code only (e.g., 'JP', 'US')
  metadata_json TEXT,  -- Non-PII metadata only
  created_at INTEGER NOT NULL
);

-- Regional Postgres: audit_log_pii
CREATE TABLE audit_log_pii (
  audit_id TEXT PRIMARY KEY REFERENCES audit_log_core(id),
  ip_address_encrypted TEXT,
  user_agent_hash TEXT,  -- Salted hash
  request_headers_encrypted TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

#### Retention Period

Define retention periods clearly for compliance:

| Type           | Retention | Basis                        |
| -------------- | --------- | ---------------------------- |
| audit_log_core | 7 years   | General legal requirements   |
| audit_log_pii  | 1 year    | GDPR minimization principle  |

### 6.3 Cache Invalidation Strategy

#### Overview

Adopt Event-driven + Version combination for cache invalidation strategy:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Cache Invalidation Strategy            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Option A: Event-driven (adopted)                â”‚
â”‚   PIIRepository.update() â†’                      â”‚
â”‚     â†’ CacheRepository.invalidate(userId)        â”‚
â”‚                                                 â”‚
â”‚ Option C: Version (combined)                    â”‚
â”‚   Add user_version column to Core DB            â”‚
â”‚   Embed version in Cache                        â”‚
â”‚   â†’ Auto-invalidate on version mismatch         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Implementation

```typescript
// On update in PIIRepository
class PIIRepository {
  async updateUserProfile(userId: string, data: UpdateUserProfileInput): Promise<void> {
    // 1. Update PII DB
    await this.db.execute('UPDATE users_pii SET name = $1, updated_at = NOW() WHERE id = $2', [
      data.name,
      userId,
    ]);

    // 2. Increment version in Core DB
    await this.coreDb.execute(
      'UPDATE users_core SET user_version = user_version + 1, updated_at = ? WHERE id = ?',
      [Date.now(), userId]
    );

    // 3. Invalidate Cache (Event-driven)
    await this.cache.invalidateUser(userId);
  }
}

// On read in CacheRepository (Version check)
class CacheRepository {
  async getCachedUser(userId: string): Promise<CachedUser | null> {
    const cached = await this.userCache.get(`user:${userId}`);
    if (!cached) return null;

    const parsed = JSON.parse(cached) as CachedUser & { version: number };

    // Version check
    const currentVersion = await this.coreDb.queryOne<{ user_version: number }>(
      'SELECT user_version FROM users_core WHERE id = ?',
      [userId]
    );

    if (currentVersion && parsed.version !== currentVersion.user_version) {
      // Version mismatch â†’ invalidate
      await this.invalidateUser(userId);
      return null;
    }

    return parsed;
  }
}
```

#### Schema Addition

```sql
-- Add version column to users_core
ALTER TABLE users_core ADD COLUMN user_version INTEGER NOT NULL DEFAULT 1;
```

### 6.4 Fallback / Circuit Breaker

#### Overview

Implement Circuit Breaker and Graceful Degradation to prevent complete auth flow stoppage during Regional PII DB failures:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Resilience Strategy                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. Circuit Breaker                              â”‚
â”‚    PII DB failure detection â†’ auto degraded modeâ”‚
â”‚    â€¢ N consecutive failures â†’ Open state        â”‚
â”‚    â€¢ After M seconds â†’ Half-Open â†’ retry        â”‚
â”‚    â€¢ On success â†’ return to Closed state        â”‚
â”‚                                                 â”‚
â”‚ 2. Graceful Degradation                         â”‚
â”‚    /userinfo â†’ Return Core only if PII fetch    â”‚
â”‚    fails                                        â”‚
â”‚    { sub: "uuid", email: null, name: null }    â”‚
â”‚                                                 â”‚
â”‚ 3. Fallback Region (optional, OFF by default)  â”‚
â”‚    EU DB down â†’ Read from US replica            â”‚
â”‚    â€» GDPR exception clause applies,            â”‚
â”‚      per-tenant opt-in                          â”‚
â”‚                                                 â”‚
â”‚ 4. Health Check Endpoint                        â”‚
â”‚    /health/pii-eu, /health/pii-us, /health/pii-jpâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Circuit Breaker Implementation

```typescript
// packages/shared/src/utils/circuit-breaker.ts

export interface CircuitBreakerConfig {
  failureThreshold: number; // Failures to Open (default: 5)
  resetTimeoutMs: number; // Time to Half-Open (default: 30000)
  halfOpenSuccessThreshold: number; // Successes to Closed (default: 2)
}

export class CircuitBreaker {
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private failures = 0;
  private lastFailureTime = 0;
  private halfOpenSuccesses = 0;

  constructor(
    private name: string,
    private config: CircuitBreakerConfig = {
      failureThreshold: 5,
      resetTimeoutMs: 30000,
      halfOpenSuccessThreshold: 2,
    }
  ) {}

  async execute<T>(fn: () => Promise<T>, fallback?: () => Promise<T>): Promise<T> {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailureTime >= this.config.resetTimeoutMs) {
        this.state = 'half-open';
        this.halfOpenSuccesses = 0;
      } else if (fallback) {
        return fallback();
      } else {
        throw new CircuitOpenError(this.name);
      }
    }

    try {
      const result = await fn();
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      if (fallback) {
        return fallback();
      }
      throw error;
    }
  }

  private onSuccess(): void {
    if (this.state === 'half-open') {
      this.halfOpenSuccesses++;
      if (this.halfOpenSuccesses >= this.config.halfOpenSuccessThreshold) {
        this.state = 'closed';
        this.failures = 0;
      }
    } else {
      this.failures = 0;
    }
  }

  private onFailure(): void {
    this.failures++;
    this.lastFailureTime = Date.now();
    if (this.failures >= this.config.failureThreshold) {
      this.state = 'open';
    }
  }
}
```

#### Graceful Degradation Implementation

```typescript
// packages/op-userinfo/src/userinfo.ts

export const userinfoHandler: UserInfoHandler = async (c, ctx) => {
  const userId = getAuthenticatedUserId(c);

  // Core is required
  const core = await ctx.core.getUserCore(userId);
  if (!core) {
    return c.json({ error: 'invalid_token' }, 401);
  }

  // Get PII via Circuit Breaker
  const profile = await piiCircuitBreaker.execute(
    () => ctx.pii.getUserProfile(userId),
    // Fallback: return null
    () => Promise.resolve(null)
  );

  // Degraded response if PII unavailable
  return c.json({
    sub: core.id,
    email: profile?.email ?? null,
    email_verified: core.email_verified,
    name: profile?.name ?? null,
    // ... other claims
    _degraded: profile === null, // Notify client of degraded state
  });
};
```

#### Fallback Region Notes

Fallback Region (EU DB down â†’ US replica) is **OFF by default** for the following reasons:

- **GDPR Risk**: Permanent operation may violate regulations
- **Exception definition required**: Position as "temporary technical failure"
- **Per-tenant opt-in**: Only available for tenants that explicitly enable it

```typescript
// Tenant configuration
interface TenantConfig {
  pii_region: Region;
  enable_fallback_region: boolean; // Default: false
  fallback_region?: Region;
}
```

### 6.5 Type-safe PII Access Control

#### Overview

Use TypeScript's type system to prevent direct PII access from authentication flows (`/authorize`, `/token`) at compile time.

#### Implementation

```typescript
// packages/shared/src/context/types.ts

/**
 * Context that cannot access PII
 * Used for /authorize, /token, /introspect, /revoke, etc.
 */
export interface AuthContext {
  core: CoreRepository;
  cache: CacheRepository;
  env: Env;
}

/**
 * Context that can access PII
 * Used for /userinfo, /admin/users, /signup, etc.
 */
export interface PIIContext extends AuthContext {
  pii: PIIRepository;
}

/**
 * Handler type definitions
 */
export type AuthHandler<E extends Env = Env> = (
  c: Context<{ Bindings: E }>,
  ctx: AuthContext
) => Promise<Response>;

export type PIIHandler<E extends Env = Env> = (
  c: Context<{ Bindings: E }>,
  ctx: PIIContext
) => Promise<Response>;
```

#### Context Factory

```typescript
// packages/shared/src/context/factory.ts

export function createAuthContext(env: Env): AuthContext {
  return {
    core: new CoreRepository(new D1Adapter(env.DB)),
    cache: new CacheRepository(
      env.USER_CACHE,
      env.CONSENT_CACHE,
      env.REBAC_CACHE,
      env.CLIENTS_CACHE
    ),
    env,
  };
}

export async function createPIIContext(env: Env, userId?: string): Promise<PIIContext> {
  const authCtx = createAuthContext(env);

  // Get appropriate PII DB via Region Router
  const piiAdapter = userId
    ? await regionRouter.getPIIAdapter(userId, authCtx.core.db)
    : regionRouter.getAdapterForRegion(env.DEFAULT_PII_REGION);

  return {
    ...authCtx,
    pii: new PIIRepository(piiAdapter, encryptionService),
  };
}
```

#### Usage in Handlers

```typescript
// packages/op-auth/src/authorize.ts

// Using AuthHandler type â†’ Accessing ctx.pii causes compile error
export const authorizeHandler: AuthHandler = async (c, ctx) => {
  // âœ… OK: Only Core and Cache accessible
  const client = await ctx.cache.getCachedClient(clientId);
  const session = await ctx.core.getSession(sessionId);

  // âŒ Compile error: Property 'pii' does not exist on type 'AuthContext'
  // const profile = await ctx.pii.getUserProfile(userId);

  return c.redirect(redirectUri);
};

// packages/op-userinfo/src/userinfo.ts

// Using PIIHandler type â†’ ctx.pii is accessible
export const userinfoHandler: PIIHandler = async (c, ctx) => {
  // âœ… OK: All accessible
  const core = await ctx.core.getUserCore(userId);
  const profile = await ctx.pii.getUserProfile(userId);
  const cached = await ctx.cache.getCachedUser(userId);

  return c.json({ sub: core.id, email: profile.email });
};
```

#### ESLint Rule Reinforcement (Optional)

For stronger enforcement, restrict PIIRepository imports via ESLint rules:

```javascript
// .eslintrc.js
module.exports = {
  rules: {
    'no-restricted-imports': [
      'error',
      {
        paths: [
          {
            name: '@authrim/shared',
            importNames: ['PIIRepository'],
            message: 'PIIRepository is not allowed in this package. Use AuthContext instead.',
          },
        ],
      },
    ],
  },
  overrides: [
    {
      // Allow in packages that handle PII
      files: ['packages/op-userinfo/**/*', 'packages/op-management/**/*'],
      rules: {
        'no-restricted-imports': 'off',
      },
    },
  ],
};
```

### 6.6 Multi-tenant Isolation Enhancement

#### Overview

Provide tenant isolation at 3 levels:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Multi-tenant Isolation Levels           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Level 1: Row-level (default)                    â”‚
â”‚   WHERE tenant_id = ?                           â”‚
â”‚   â†’ All tenants share the same DB               â”‚
â”‚   â†’ Most cost-efficient                         â”‚
â”‚                                                 â”‚
â”‚ Level 2: Schema-level (Enterprise)              â”‚
â”‚   tenant_abc.users_pii                          â”‚
â”‚   tenant_xyz.users_pii                          â”‚
â”‚   â†’ Same DB instance, different schemas         â”‚
â”‚   â†’ Can take individual backups                 â”‚
â”‚                                                 â”‚
â”‚ Level 3: Database-level (highest isolation)     â”‚
â”‚   tenant_abc â†’ dedicated Postgres instance     â”‚
â”‚   â†’ Complete physical separation                â”‚
â”‚   â†’ "This tenant is EU-only" is easy            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Implementation: Abstraction in Repository

```typescript
// packages/shared/src/repositories/pii/index.ts

export class PIIRepository {
  static forTenant(
    tenantId: string,
    tenantConfig: TenantConfig,
    regionRouter: RegionRouter
  ): PIIRepository {
    const isolation = tenantConfig.isolation_level || 'row';

    switch (isolation) {
      case 'database':
        // Level 3: Dedicated DB instance
        const dedicatedDb = regionRouter.getDedicatedAdapter(tenantId);
        return new PIIRepository(dedicatedDb, tenantId, 'public');

      case 'schema':
        // Level 2: Dedicated schema
        const sharedDb = regionRouter.getAdapterForRegion(tenantConfig.pii_region);
        return new PIIRepository(sharedDb, tenantId, `tenant_${tenantId}`);

      case 'row':
      default:
        // Level 1: Row-level isolation
        const defaultDb = regionRouter.getAdapterForRegion(tenantConfig.pii_region);
        return new PIIRepository(defaultDb, tenantId, 'public');
    }
  }

  constructor(
    private db: DatabaseAdapter,
    private tenantId: string,
    private schema: string
  ) {}

  async getUserProfile(userId: string): Promise<UserProfile | null> {
    // Level 1 & 2: Include tenant_id in WHERE clause
    // Level 3: No tenant_id check needed (dedicated DB)
    const query =
      this.schema === 'public'
        ? 'SELECT * FROM users_pii WHERE id = $1 AND tenant_id = $2'
        : `SELECT * FROM ${this.schema}.users_pii WHERE id = $1`;

    const params = this.schema === 'public' ? [userId, this.tenantId] : [userId];

    return this.db.queryOne<UserProfile>(query, params);
  }
}
```

#### Plan-based Offerings

| Plan            | Isolation Level  | Additional Cost |
| --------------- | ---------------- | --------------- |
| Free            | Row-level        | -               |
| Professional    | Row-level        | -               |
| Enterprise      | Schema-level     | +               |
| Enterprise Plus | Database-level   | ++              |

### 6.7 Soft Delete + Anonymization

#### Overview

Design deletion strategy for GDPR "Right to be Forgotten" compliance:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Deletion Strategy                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ PII Layer:                                      â”‚
â”‚   â€¢ Hard delete (physical deletion)            â”‚
â”‚   â€¢ Or anonymize:                              â”‚
â”‚     email â†’ "deleted_{userId}@anonymized.local"â”‚
â”‚     name â†’ NULL                                 â”‚
â”‚     phone â†’ NULL                                â”‚
â”‚                                                 â”‚
â”‚ Core Layer:                                     â”‚
â”‚   â€¢ Soft delete (is_deleted = 1)               â”‚
â”‚   â€¢ Keep user_id (for audit log references)    â”‚
â”‚   â€¢ relationships â†’ CASCADE DELETE             â”‚
â”‚                                                 â”‚
â”‚ Cache Layer:                                    â”‚
â”‚   â€¢ Immediate invalidation                     â”‚
â”‚                                                 â”‚
â”‚ Audit Log:                                      â”‚
â”‚   â€¢ Keep Core side (legal requirement)         â”‚
â”‚   â€¢ Anonymize PII side                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Implementation

```typescript
// packages/shared/src/services/user.service.ts

export class UserService {
  /**
   * Process GDPR deletion request
   * @param userId - Target user ID to delete
   * @param mode - 'hard_delete' or 'anonymize'
   */
  async deleteUser(userId: string, mode: 'hard_delete' | 'anonymize' = 'anonymize'): Promise<void> {
    // 1. Immediately invalidate Cache
    await this.cache.invalidateUser(userId);
    await this.cache.invalidateRBAC(userId);

    // 2. PII processing
    if (mode === 'hard_delete') {
      await this.pii.deleteUserProfile(userId);
    } else {
      await this.pii.anonymizeUserProfile(userId);
    }

    // 3. Soft delete Core
    await this.core.updateUserCore(userId, {
      is_deleted: true,
      deleted_at: Date.now(),
    });

    // 4. Delete Relationships (CASCADE)
    await this.core.deleteUserRelationships(userId);

    // 5. Delete Sessions
    await this.core.deleteUserSessions(userId);

    // 6. Delete Passkeys
    await this.core.deleteUserPasskeys(userId);

    // 7. Anonymize Audit Log (PII)
    await this.pii.anonymizeAuditLogs(userId);
  }
}

// packages/shared/src/repositories/pii/index.ts

export class PIIRepository {
  async anonymizeUserProfile(userId: string): Promise<void> {
    await this.db.execute(
      `UPDATE users_pii SET
        email_encrypted = $1,
        email_blind_index = $2,
        name = NULL,
        given_name = NULL,
        family_name = NULL,
        phone_number_encrypted = NULL,
        address_encrypted = NULL,
        anonymized_at = NOW()
      WHERE id = $3`,
      [
        this.encryption.encrypt(`deleted_${userId}@anonymized.local`),
        createBlindIndex(`deleted_${userId}@anonymized.local`, this.indexKey),
        userId,
      ]
    );
  }

  async anonymizeAuditLogs(userId: string): Promise<void> {
    // Anonymize PII-side audit logs
    await this.db.execute(
      `UPDATE audit_log_pii SET
        ip_address_encrypted = NULL,
        user_agent_hash = NULL,
        anonymized_at = NOW()
      WHERE audit_id IN (
        SELECT id FROM audit_log_core WHERE user_id = $1
      )`,
      [userId]
    );
  }
}
```

#### Schema

```sql
-- Add deletion-related columns to users_core
ALTER TABLE users_core ADD COLUMN is_deleted INTEGER NOT NULL DEFAULT 0;
ALTER TABLE users_core ADD COLUMN deleted_at INTEGER;

CREATE INDEX idx_users_core_is_deleted ON users_core(is_deleted);

-- Add anonymization-related columns to users_pii
ALTER TABLE users_pii ADD COLUMN anonymized_at TIMESTAMPTZ;
```

### 6.8 Key Rotation Strategy

#### Overview

Implement periodic key rotation for encryption key lifecycle management:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Key Rotation Strategy                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Rotation Schedule:                              â”‚
â”‚   â€¢ Master Key (KEK): Once per year            â”‚
â”‚   â€¢ Tenant DEK: Once per year or on-demand     â”‚
â”‚   â€¢ Index Key (Blind Index): No rotation       â”‚
â”‚                                                 â”‚
â”‚ Rotation Process:                               â”‚
â”‚   1. Generate new DEK                          â”‚
â”‚   2. Set old DEK to "decrypt only" mode        â”‚
â”‚   3. Re-encrypt in background                  â”‚
â”‚   4. Delete old DEK after completion           â”‚
â”‚                                                 â”‚
â”‚ Key Versioning:                                 â”‚
â”‚   encrypted_value = version:iv:ciphertext      â”‚
â”‚   Example: v2:abc123...:encrypted_email...     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Implementation

```typescript
// packages/shared/src/encryption/key-manager.ts

export interface EncryptedValue {
  version: number;
  iv: string;
  ciphertext: string;
}

export class KeyManager {
  private keys: Map<number, CryptoKey> = new Map();
  private currentVersion: number;

  constructor(
    private kms: KMSClient,
    private tenantId: string
  ) {}

  async initialize(): Promise<void> {
    // Get current key version from KMS
    const keyMetadata = await this.kms.getKeyMetadata(this.tenantId);
    this.currentVersion = keyMetadata.currentVersion;

    // Load current key and previous one (for rotation)
    for (const version of [this.currentVersion, this.currentVersion - 1]) {
      if (version > 0) {
        const wrappedKey = await this.kms.getWrappedKey(this.tenantId, version);
        const unwrappedKey = await this.kms.unwrapKey(wrappedKey);
        this.keys.set(version, unwrappedKey);
      }
    }
  }

  async encrypt(plaintext: string): Promise<string> {
    const key = this.keys.get(this.currentVersion);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const ciphertext = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      new TextEncoder().encode(plaintext)
    );

    return `v${this.currentVersion}:${base64url(iv)}:${base64url(ciphertext)}`;
  }

  async decrypt(encrypted: string): Promise<string> {
    const [versionStr, ivStr, ciphertextStr] = encrypted.split(':');
    const version = parseInt(versionStr.slice(1), 10);
    const iv = base64urlDecode(ivStr);
    const ciphertext = base64urlDecode(ciphertextStr);

    const key = this.keys.get(version);
    if (!key) {
      throw new Error(`Key version ${version} not available`);
    }

    const plaintext = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ciphertext);

    return new TextDecoder().decode(plaintext);
  }

  async rotateKey(): Promise<void> {
    // 1. Generate new key
    const newVersion = this.currentVersion + 1;
    const newKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, [
      'encrypt',
      'decrypt',
    ]);

    // 2. Wrap and store in KMS
    const wrappedKey = await this.kms.wrapKey(newKey);
    await this.kms.storeWrappedKey(this.tenantId, newVersion, wrappedKey);

    // 3. Update current key
    this.keys.set(newVersion, newKey);
    this.currentVersion = newVersion;

    // 4. Schedule background re-encryption
    await this.scheduleReEncryption(newVersion);
  }
}
```

### 6.9 Monitoring / Observability

#### Overview

Monitor PII and Non-PII layers separately to ensure PII doesn't impact auth flows:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Monitoring Strategy                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Metrics by Layer:                               â”‚
â”‚   â€¢ Core Layer: /authorize, /token p50/p99     â”‚
â”‚   â€¢ PII Layer: /userinfo, /admin p50/p99       â”‚
â”‚   â€¢ Cache Layer: hit rate, miss rate           â”‚
â”‚                                                 â”‚
â”‚ Alerts:                                         â”‚
â”‚   â€¢ PII DB latency > 500ms â†’ warning           â”‚
â”‚   â€¢ PII DB latency > 2000ms â†’ critical         â”‚
â”‚   â€¢ Core DB latency > 100ms â†’ warning          â”‚
â”‚   â€¢ Circuit Breaker open â†’ critical            â”‚
â”‚                                                 â”‚
â”‚ Dashboards:                                     â”‚
â”‚   â€¢ "Auth Performance" (Core only)             â”‚
â”‚   â€¢ "User Data Access" (PII metrics)           â”‚
â”‚   â€¢ "Cache Efficiency" (hit rates)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### Implementation

```typescript
// packages/shared/src/monitoring/metrics.ts

export interface Metrics {
  // Latency histograms
  recordLatency(layer: 'core' | 'pii' | 'cache', operation: string, durationMs: number): void;

  // Counters
  incrementCounter(name: string, tags?: Record<string, string>): void;

  // Gauges
  setGauge(name: string, value: number, tags?: Record<string, string>): void;
}

// Recording metrics in Repository
class PIIRepository {
  constructor(
    private db: DatabaseAdapter,
    private metrics: Metrics
  ) {}

  async getUserProfile(userId: string): Promise<UserProfile | null> {
    const start = Date.now();
    try {
      const result = await this.db.queryOne<UserProfile>('SELECT * FROM users_pii WHERE id = $1', [
        userId,
      ]);
      this.metrics.recordLatency('pii', 'getUserProfile', Date.now() - start);
      return result;
    } catch (error) {
      this.metrics.incrementCounter('pii_errors', { operation: 'getUserProfile' });
      throw error;
    }
  }
}
```

---

## 7. Implementation Plan

### Phase 1: Database Adapter Layer

| Task                            | Priority | Complexity |
| ------------------------------- | -------- | ---------- |
| DatabaseAdapter interface def   | High     | Low        |
| D1Adapter implementation        | High     | Low        |
| KVAdapter implementation        | High     | Low        |
| DOAdapter implementation        | High     | Medium     |
| PostgresAdapter implementation  | High     | Medium     |
| Basic tests                     | High     | Low        |

### Phase 2: Repository Layer

| Task                       | Priority | Complexity |
| -------------------------- | -------- | ---------- |
| CoreRepository impl        | High     | Medium     |
| PIIRepository impl         | High     | Medium     |
| CacheRepository impl       | High     | Low        |
| RegionRouter impl          | High     | Medium     |
| Type-safe Context impl     | High     | Low        |

### Phase 3: Encryption & Security

| Task                          | Priority | Complexity |
| ----------------------------- | -------- | ---------- |
| Field-level encryption impl   | High     | Medium     |
| Blind Index impl              | High     | Medium     |
| Key Management (KMS integ)    | High     | High       |
| Key Rotation impl             | Medium   | High       |

### Phase 4: Existing Code Migration

| Task                                | Priority | Complexity |
| ----------------------------------- | -------- | ---------- |
| Migrate handlers to Repository      | High     | High       |
| DB schema split migration           | High     | High       |
| Cache layer separation              | Medium   | Medium     |
| Audit Log separation                | Medium   | Medium     |

### Phase 5: Resilience & Observability

| Task                          | Priority | Complexity |
| ----------------------------- | -------- | ---------- |
| Circuit Breaker impl          | Medium   | Medium     |
| Graceful Degradation impl     | Medium   | Low        |
| Metrics / Monitoring impl     | Medium   | Medium     |
| Health Check endpoint         | Low      | Low        |

### Phase 6: Multi-tenant & GDPR

| Task                             | Priority | Complexity |
| -------------------------------- | -------- | ---------- |
| Multi-tenant Isolation (L2, L3) | Medium   | Medium     |
| Soft Delete + Anonymization     | High     | Low        |
| Data Export (GDPR portability)  | Medium   | Medium     |

---

## 8. Future Extensibility

### 8.1 AWS Migration Path

This design enables easy future migration to AWS:

| Cloudflare        | AWS Equivalent                      |
| ----------------- | ----------------------------------- |
| D1                | Aurora Serverless v2                |
| Durable Objects   | DynamoDB + Item Locking             |
| KV                | ElastiCache (Redis) or DynamoDB     |
| Workers           | Lambda@Edge                         |
| Regional Postgres | RDS (Postgres)                      |

During migration, only add DatabaseAdapter implementations; Repository layer and above require no changes.

### 8.2 Additional Authentication Methods

Repository pattern enables easy addition of new auth methods:

- **FIDO2/WebAuthn**: Already supported (Passkey in CoreRepository)
- **mTLS**: Certificates stored in CoreRepository
- **SAML**: Assertions are temporary, metadata in CoreRepository

### 8.3 Additional PII Types

Extend PIIRepository to support new PII types:

- **Biometric data**: Face recognition templates, etc. (highest encryption level required)
- **Payment info**: PCI DSS compliance required (consider separate dedicated service)
- **Medical info**: HIPAA compliance required (Level 3 isolation mandatory)

---

## 9. Design Philosophy

### 9.1 Why Physical DB Separation?

**Choice:** Separate D1_CORE + D1_PII from the start (Approach B)

**Reasons:**

1. **Audit/compliance clarity**: Can clearly state "PII is stored in separate DB". For GDPR/CCPA audits, "DB-level separation" is more convincing than "table-level separation".

2. **Easier regional deployment**: When adding EU-only PII DB, just add new D1 binding without schema changes. Table separation makes later physical separation difficult.

3. **Enforced access control**: Cannot access PII without explicitly obtaining PIIContext. Code reviews can immediately see "this handler accesses PII".

**Tradeoffs:**

- No JOINs available â†’ Parallel queries with `Promise.all` (no issues in practice)
- No cross-DB transactions â†’ State management via `pii_status`

### 9.2 Why "Partition" Instead of "Region"?

**Choice:** Use "partition" instead of "region"

**Reasons:**

1. **Avoid confusion with Durable Object shards**: Existing code has `region-sharding.ts` for DO shards. Avoid naming collision.
2. **Flexible routing**: Not just geographic (`eu`, `apac`), but tenant (`tenant-acme`), plan (`premium`), attribute (`high-security`), etc. "Region" implies too strong a geographic meaning.

### 9.3 Why IP Routing is Low Trust?

**Choice:** IP-based routing is `fallback only`, OFF by default

**Reasons:**

1. **VPN/Proxy/Warp**: High likelihood users use IPs from different countries
2. **Roaming**: Mobile users frequently move between countries
3. **Not legal evidence**: IP cannot be used as evidence for GDPR's "EU data stored in EU"
4. **Trusted sources**: `declared_residence` (user self-declaration) or tenant policy takes priority

### 9.4 Why pii_status State Machine?

**Choice:** Manage distributed write state with `pii_status`

**Reasons:**

1. **No cross-DB transactions**: D1_CORE and D1_PII are separate DBs so ACID transactions are impossible
2. **Failure tracking**: Even if PII write fails, can track/retry via `pii_status: 'failed'`
3. **M2M support**: `pii_status: 'none'` explicitly indicates users without PII (client_credentials flow)

**State transitions:**

```
New creation: pending â†’ active (success) / failed (failure)
M2M: none (no PII)
Deletion: active â†’ deleted (Tombstone created)
```

### 9.5 Why PII Sensitivity Classes?

**Choice:** Classify sensitivity levels with `pii_class`

**Reasons:**

1. **Purpose-based access control**: Distinguish IDENTITY_CORE (required for auth) from DEMOGRAPHIC (GDPR Art.9 special categories)
2. **Retention policies**: Can set different retention periods per class
3. **Audit support**: Can clearly explain "why separated"

### 9.6 Why Tombstone Table?

**Choice:** Record deletion facts in `users_pii_tombstone`

**Reasons:**

1. **GDPR Art.17 compliance**: "Right to be Forgotten" implementation
2. **Re-registration prevention**: Prevent deleted email addresses from being re-registered during retention period
3. **Audit trail**: Record "when, who, why deleted"
4. **No PII stored**: Tombstone contains only metadata (email_blind_index), actual PII is deleted

---

## 10. Implementation Rationale

### 10.1 DatabaseAdapter Interface

**Purpose:** Abstract multiple DB backends

**Implementation reasons:**

- Currently D1 only, but can support Postgres (Hyperdrive), DynamoDB, MySQL in future
- Can use mock adapters in tests
- Can mix different backends per partition (e.g., default=D1, tenant-acme=Postgres)

### 10.2 Repository Pattern

**Purpose:** Type-safe data access without writing SQL directly

**Implementation reasons:**

- Current `admin.ts` has 30+ direct SQL. Low maintainability
- Reduces SQL injection risk via Repository
- Enforces PII/non-PII access patterns

### 10.3 Context Types (AuthContext / PIIContext)

**Purpose:** Control PII access via type system

**Implementation reasons:**

- Handlers with `AuthContext` cannot access PII (compile error)
- Only promote to `PIIContext` when PII is needed
- Code reviews can immediately see "this endpoint accesses PII"

### 10.4 Blind Index (email_blind_index)

**Purpose:** Enable searching while keeping PII encrypted

**Implementation reasons:**

- Searching email directly in PII DB leaves PII in indexes
- With Blind Index, search keys are only hashed values
- Even if DB leaks, cannot recover original email from Blind Index

---

## 11. Deferred Features

### 11.1 PIIPolicyEngine (Scope-based PII Evaluation)

**Content:** Engine to evaluate access policies per PII class

**Reason for deferral:**

- Currently PII read/write is controlled at Context level
- Phase 8 (Policy Integration) prioritized Token Embedding and Check API (âœ… Complete)
- PII scope-based control to be extended in Phase 10 (Policy Admin Console)
- Current priority: DB separation foundation > policy engine

**Future implementation:**

```typescript
interface PIIPolicyEngine {
  canAccess(userId: string, piiClass: PIIClass, scope: string): Promise<boolean>;
}
```

### 11.2 Partition Migration API

**Content:** API to move user's PII to different partition

**Reason for deferral:**

- Initial setup has all users in default partition
- When adding new partition, only route new users
- Existing user migration can be handled via manual operation

**Future implementation:**

```
POST /api/admin/users/:id/migrate-pii
{
  "targetPartition": "eu",
  "deleteFromSource": true
}
```

### 11.3 Audit Log External Export

**Content:** Auto-export audit_log_pii to R2/Logpush/SIEM

**Reason for deferral:**

- Currently kept as "recent buffer" in D1
- Volume increase to be addressed in Phase 11 (Security & QA)
- Current priority: Foundation implementation > export automation

**Future implementation:**

- Export via Scheduled Worker
- Track with `exported_at` column
- Output to R2 or Logpush

### 11.4 PII Encryption at Rest

**Content:** Encrypt each users_pii column at rest

**Reason for deferral:**

- D1 is Cloudflare managed service, disk encryption is standard
- Application-layer encryption has significant performance impact
- Current priority: DB separation > column encryption

**Future implementation (if needed):**

- Column encryption with AES-GCM
- Encryption keys in KV/Secrets
- Introduce after performance testing

### 11.5 Multi-Region Replication

**Content:** Cross-region replication for PII DB

**Reason for deferral:**

- D1 is single-region (currently)
- Waiting for Cloudflare D1 roadmap
- Currently addressed via per-partition D1

**Future implementation:**

- Evaluate when D1 supports multi-region
- Or implement via Hyperdrive + Postgres

### 11.6 GDPR Data Portability API

**Content:** API to export all user PII (GDPR Art.20)

**Reason for deferral:**

- Priority: Deletion (Art.17) > Portability (Art.20)
- Currently manual export via Admin API is possible
- User-facing endpoint to be added in Phase 10 (SDK & API)

**Future implementation:**

```
GET /api/user/export-data
Response: { user_data: {...}, linked_identities: [...], ... }
```

---

## Appendix

### A. File Structure

```
packages/shared/src/
â”œâ”€â”€ db/
â”‚   â”œâ”€â”€ adapter.ts              # DatabaseAdapter interface
â”‚   â”œâ”€â”€ adapters/
â”‚   â”‚   â”œâ”€â”€ d1-adapter.ts       # Cloudflare D1
â”‚   â”‚   â”œâ”€â”€ kv-adapter.ts       # Cloudflare KV
â”‚   â”‚   â”œâ”€â”€ do-adapter.ts       # Durable Objects
â”‚   â”‚   â””â”€â”€ postgres-adapter.ts # Regional Postgres
â”‚   â””â”€â”€ region-router.ts        # PII region routing
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ user-core.repository.ts
â”‚   â”‚   â”œâ”€â”€ passkey.repository.ts
â”‚   â”‚   â”œâ”€â”€ session.repository.ts
â”‚   â”‚   â”œâ”€â”€ role.repository.ts
â”‚   â”‚   â”œâ”€â”€ relationship.repository.ts
â”‚   â”‚   â””â”€â”€ index.ts            # CoreRepository facade
â”‚   â”œâ”€â”€ pii/
â”‚   â”‚   â”œâ”€â”€ user-profile.repository.ts
â”‚   â”‚   â”œâ”€â”€ identifier.repository.ts
â”‚   â”‚   â”œâ”€â”€ audit-log-pii.repository.ts
â”‚   â”‚   â””â”€â”€ index.ts            # PIIRepository facade
â”‚   â”œâ”€â”€ cache/
â”‚   â”‚   â”œâ”€â”€ user-cache.repository.ts
â”‚   â”‚   â”œâ”€â”€ rbac-cache.repository.ts
â”‚   â”‚   â”œâ”€â”€ consent-cache.repository.ts
â”‚   â”‚   â””â”€â”€ index.ts            # CacheRepository facade
â”‚   â””â”€â”€ index.ts                # Export all repositories
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ user.service.ts         # Combines Core+PII+Cache
â”‚   â””â”€â”€ encryption.service.ts   # Field-level encryption
â”œâ”€â”€ context/
â”‚   â”œâ”€â”€ types.ts                # AuthContext, PIIContext
â”‚   â””â”€â”€ factory.ts              # Context factories
â”œâ”€â”€ encryption/
â”‚   â”œâ”€â”€ key-manager.ts          # Key management
â”‚   â”œâ”€â”€ blind-index.ts          # Blind index utilities
â”‚   â””â”€â”€ field-encryption.ts     # Field-level encryption
â”œâ”€â”€ resilience/
â”‚   â”œâ”€â”€ circuit-breaker.ts      # Circuit breaker
â”‚   â””â”€â”€ fallback.ts             # Fallback strategies
â””â”€â”€ monitoring/
    â””â”€â”€ metrics.ts              # Metrics utilities
```

### B. Schema Split

#### Global D1: users_core

```sql
CREATE TABLE users_core (
  id TEXT PRIMARY KEY,
  tenant_id TEXT NOT NULL DEFAULT 'default',
  pii_region TEXT NOT NULL DEFAULT 'eu',
  email_verified INTEGER DEFAULT 0,
  user_type TEXT NOT NULL DEFAULT 'end_user',
  user_version INTEGER NOT NULL DEFAULT 1,
  is_deleted INTEGER NOT NULL DEFAULT 0,
  deleted_at INTEGER,
  created_at INTEGER NOT NULL,
  updated_at INTEGER NOT NULL,
  last_login_at INTEGER
);

CREATE INDEX idx_users_core_tenant_id ON users_core(tenant_id);
CREATE INDEX idx_users_core_is_deleted ON users_core(is_deleted);
```

#### Regional Postgres: users_pii

```sql
CREATE TABLE users_pii (
  id TEXT PRIMARY KEY,
  tenant_id TEXT NOT NULL DEFAULT 'default',
  email_encrypted TEXT NOT NULL,
  email_blind_index TEXT NOT NULL,
  name TEXT,
  given_name TEXT,
  family_name TEXT,
  middle_name TEXT,
  nickname TEXT,
  preferred_username TEXT,
  profile TEXT,
  picture TEXT,
  website TEXT,
  gender TEXT,
  birthdate TEXT,
  zoneinfo TEXT,
  locale TEXT,
  phone_number_encrypted TEXT,
  address_encrypted TEXT,
  anonymized_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX idx_users_pii_tenant_id ON users_pii(tenant_id);
CREATE UNIQUE INDEX idx_users_pii_email_blind_index ON users_pii(tenant_id, email_blind_index);
```

---

## Change History

| Date       | Version | Changes        |
| ---------- | ------- | -------------- |
| 2025-12-12 | 1.0     | Initial draft  |
