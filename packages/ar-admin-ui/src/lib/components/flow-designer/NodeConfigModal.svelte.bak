<script lang="ts">
	import type { GraphNode, GraphNodeType } from '$lib/api/admin-flows';

	interface Props {
		node: GraphNode | null;
		onSave: (nodeId: string, updates: { label: string; config: Record<string, unknown> }) => void;
		onClose: () => void;
		onDelete?: (nodeId: string) => void;
	}

	let { node, onSave, onClose, onDelete }: Props = $props();

	let label = $state('');
	let configJson = $state('{}');
	let configError = $state('');

	// JSON section collapse state - persisted across nodes
	let jsonExpanded = $state(false);

	// Form-based config values
	let identifierType = $state('email');
	let authMethods = $state<string[]>(['password']);
	let mfaFactor = $state('totp');
	let mfaFactors = $state<string[]>(['totp']); // Multiple MFA factors
	let redirectTo = $state('post_login');

	// Auth Method Select config (v1 selection node)
	let authMethodSelectMethods = $state<string[]>(['password', 'passkey']);

	// Login Method Select config (v1 selection node)
	let loginMethodSelectMethods = $state<string[]>(['email', 'social']);

	// Check Session config (v1 declarative)
	let sessionFact = $state('session.authenticated');

	// Error config (v1 screen-based)
	let errorReason = $state('unknown_error');
	let errorAllowRetry = $state(false);

	// Login config
	let loginMethods = $state<string[]>(['password']);
	let loginRememberMe = $state(true);

	// Register config
	let registerRequireVerification = $state(true);
	let registerAutoLogin = $state(true);

	// User Input fields
	interface FieldConfig {
		name: string;
		type: 'text' | 'email' | 'phone' | 'date' | 'select' | 'checkbox';
		label?: string;
		required?: boolean;
	}
	let userInputFields = $state<FieldConfig[]>([]);

	// Decision Node config
	interface DecisionBranch {
		id: string;
		label: string;
		condition: {
			key: string;
			operator: string;
			value?: unknown;
			logic?: 'and' | 'or';
			conditions?: unknown[];
		};
		priority: number;
	}
	let decisionBranches = $state<DecisionBranch[]>([]);
	let decisionDefaultBranch = $state('');

	// Switch Node config
	interface SwitchCase {
		id: string;
		label: string;
		values: (string | number | boolean)[];
	}
	let switchKey = $state('');
	let switchCases = $state<SwitchCase[]>([]);
	let switchDefaultCase = $state('');

	// Sync with node when it changes
	$effect(() => {
		if (node) {
			label = node.data.label || '';
			const config = node.data.config || {};
			configJson = JSON.stringify(config, null, 2);
			configError = '';

			// Sync form values from config
			if (node.type === 'identifier') {
				identifierType = (config.type as string) || 'email';
			} else if (node.type === 'auth_method') {
				// Support both single method and array of methods
				if (Array.isArray(config.methods)) {
					authMethods = config.methods as string[];
				} else if (config.method) {
					authMethods = [config.method as string];
				} else {
					authMethods = ['password'];
				}
			} else if (node.type === 'mfa') {
				// Support both single factor and multiple factors
				if (Array.isArray(config.factors)) {
					mfaFactors = config.factors as string[];
				} else {
					mfaFactor = (config.factor as string) || 'totp';
					mfaFactors = [mfaFactor];
				}
			} else if (node.type === 'auth_method_select') {
				authMethodSelectMethods = (config.available_methods as string[]) || ['password', 'passkey'];
			} else if (node.type === 'login_method_select') {
				loginMethodSelectMethods = (config.available_methods as string[]) || ['email', 'social'];
			} else if (node.type === 'redirect') {
				// Support new `to` semantic destination
				redirectTo = (config.to as string) || 'post_login';
			} else if (node.type === 'check_session') {
				// Support both new `fact` and legacy `key/operator`
				sessionFact = (config.fact as string) || 'session.authenticated';
			} else if (node.type === 'error') {
				errorReason = (config.reason as string) || 'unknown_error';
				errorAllowRetry = config.allow_retry === true;
			} else if (node.type === 'login') {
				if (Array.isArray(config.methods)) {
					loginMethods = config.methods as string[];
				} else {
					loginMethods = ['password'];
				}
				loginRememberMe = config.remember_me !== false;
			} else if (node.type === 'register') {
				registerRequireVerification = config.require_email_verification !== false;
				registerAutoLogin = config.auto_login !== false;
			} else if (node.type === 'user_input') {
				userInputFields = (config.fields as FieldConfig[]) || [];
			} else if (node.type === 'consent') {
				consentTypes = (config.consents as string[]) || ['terms'];
			} else if (node.type === 'decision') {
				decisionBranches = (config.branches as DecisionBranch[]) || [];
				decisionDefaultBranch = (config.defaultBranch as string) || '';
			} else if (node.type === 'switch') {
				switchKey = (config.switchKey as string) || '';
				switchCases = (config.cases as SwitchCase[]) || [];
				switchDefaultCase = (config.defaultCase as string) || '';
			}
		}
	});

	// Update JSON when form values change
	function updateConfigFromForm() {
		if (!node) return;

		let config: Record<string, unknown> = {};

		switch (node.type) {
			case 'identifier':
				config = { type: identifierType };
				break;
			case 'auth_method':
				config = { methods: authMethods };
				break;
			case 'auth_method_select':
				config = { available_methods: authMethodSelectMethods };
				break;
			case 'login_method_select':
				config = { available_methods: loginMethodSelectMethods };
				break;
			case 'mfa':
				config = { factors: mfaFactors };
				break;
			case 'redirect':
				config = { to: redirectTo };
				break;
			case 'check_session':
				config = { fact: sessionFact };
				break;
			case 'error':
				config = { reason: errorReason, allow_retry: errorAllowRetry };
				break;
			case 'login':
				config = { methods: loginMethods, remember_me: loginRememberMe };
				break;
			case 'register':
				config = {
					require_email_verification: registerRequireVerification,
					auto_login: registerAutoLogin
				};
				break;
			case 'user_input':
				config = { fields: userInputFields };
				break;
			case 'consent':
				config = { consents: consentTypes };
				break;
			case 'decision':
				config = {
					branches: decisionBranches,
					defaultBranch: decisionDefaultBranch || undefined
				};
				break;
			case 'switch':
				config = {
					switchKey,
					cases: switchCases,
					defaultCase: switchDefaultCase || undefined
				};
				break;
			default:
				try {
					config = JSON.parse(configJson);
				} catch {
					return;
				}
		}

		configJson = JSON.stringify(config, null, 2);
	}

	function handleSave() {
		if (!node) return;

		try {
			const config = JSON.parse(configJson);
			configError = '';
			onSave(node.id, { label, config });
			onClose();
		} catch {
			configError = 'Invalid JSON';
		}
	}

	function handleDelete() {
		if (node && onDelete && canDelete(node.type)) {
			onDelete(node.id);
			onClose();
		}
	}

	function canDelete(type: GraphNodeType): boolean {
		return type !== 'start';
	}

	function getNodeTypeLabel(type: GraphNodeType): string {
		const labels: Partial<Record<GraphNodeType, string>> = {
			// 1. Control Nodes
			start: 'Start',
			end: 'End',
			goto: 'Goto',
			// 2. Check Nodes
			check_session: 'Condition',
			check_auth_level: 'Check Auth Level',
			check_first_login: 'Check First Login',
			check_user_attribute: 'Check User Attribute',
			check_context: 'Check Context',
			check_risk: 'Check Risk',
			// 3. Selection Nodes
			auth_method_select: 'Auth Method Select',
			login_method_select: 'Login Method Select',
			identifier: 'Identifier',
			profile_input: 'Profile Input',
			custom_form: 'Custom Form',
			information: 'Information',
			challenge: 'Challenge',
			// 4. Authentication Nodes
			login: 'Login',
			mfa: 'MFA',
			register: 'Register',
			// 5. Consent Nodes
			consent: 'Consent',
			check_consent_status: 'Check Consent Status',
			record_consent: 'Record Consent',
			// 6. Resolve Nodes
			resolve_tenant: 'Resolve Tenant',
			resolve_org: 'Resolve Organization',
			resolve_policy: 'Resolve Policy',
			// 7. Session Nodes
			issue_tokens: 'Issue Tokens',
			refresh_session: 'Refresh Session',
			revoke_session: 'Revoke Session',
			bind_device: 'Bind Device',
			link_account: 'Link Account',
			// 8. Side Effect Nodes
			redirect: 'Redirect',
			webhook: 'Webhook',
			event_emit: 'Emit Event',
			email_send: 'Send Email',
			sms_send: 'Send SMS',
			push_notify: 'Push Notification',
			// 9. Logic Nodes
			decision: 'Decision',
			switch: 'Switch',
			// 10. Policy Nodes
			policy_check: 'Policy Check',
			// 11. Error Nodes
			error: 'Error',
			log: 'Log',
			// Legacy (deprecated)
			auth_method: 'Authentication',
			user_input: 'User Input',
			wait_input: 'Wait Input',
			condition: 'Condition',
			check_user: 'Check User',
			risk_check: 'Risk Check',
			set_variable: 'Set Variable',
			call_api: 'Call API',
			send_notification: 'Notification'
		};
		return labels[type] || type;
	}

	function getNodeDescription(type: GraphNodeType): string {
		const descriptions: Partial<Record<GraphNodeType, string>> = {
			// 1. Control Nodes
			start: 'Entry point of the authentication flow. Every flow must begin here.',
			end: 'Successful completion of the flow. Use this when authentication succeeds.',
			goto: 'Jump to another node in the flow, useful for creating loops or skipping steps.',
			// 2. Check Nodes
			check_session: 'Check session, user, or context state using fact-based conditions.',
			check_auth_level: 'Verify if user meets the required authentication level (basic, MFA, etc.).',
			check_first_login: 'Determine if this is the user\'s first login to trigger onboarding flows.',
			check_user_attribute: 'Check specific user attributes like email_verified or phone_verified.',
			check_context: 'Evaluate request context such as new device, IP address, or location.',
			check_risk: 'Evaluate risk score based on user behavior and context signals.',
			// 3. Selection Nodes
			auth_method_select: 'Let user choose their preferred authentication method (password, passkey, etc.).',
			login_method_select: 'Let user choose how to login (email, social provider, etc.).',
			identifier: 'Collect user identifier such as email address, phone number, or username.',
			profile_input: 'Collect user profile information like display name or avatar.',
			custom_form: 'Display a custom form with configurable fields.',
			information: 'Display informational content or announcements to the user.',
			challenge: 'Present a security challenge like CAPTCHA or security questions.',
			// 4. Authentication Nodes
			login: 'Execute the login process with the specified authentication method.',
			mfa: 'Require multi-factor authentication (TOTP, SMS, email code).',
			register: 'Create a new user account with optional email verification.',
			// 5. Consent Nodes
			consent: 'Request user consent for terms, privacy policy, or data processing.',
			check_consent_status: 'Check if user has already given consent for a specific type.',
			record_consent: 'Record that user has given or withdrawn consent.',
			// 6. Resolve Nodes
			resolve_tenant: 'Determine tenant from email domain for multi-tenant scenarios.',
			resolve_org: 'Resolve organization membership from user attributes.',
			resolve_policy: 'Load and apply authentication policies for the resolved context.',
			// 7. Session Nodes
			issue_tokens: 'Generate and issue access tokens and refresh tokens.',
			refresh_session: 'Extend or refresh the current session.',
			revoke_session: 'Invalidate the current or all user sessions.',
			bind_device: 'Associate the current device with the user for future recognition.',
			link_account: 'Link a social provider account to the existing user.',
			// 8. Side Effect Nodes
			redirect: 'Redirect user to a semantic destination (post-login, settings, etc.).',
			webhook: 'Call an external webhook URL with flow data.',
			event_emit: 'Emit a custom event for analytics or external systems.',
			email_send: 'Send an email using a predefined template.',
			sms_send: 'Send an SMS message to the user\'s phone.',
			push_notify: 'Send a push notification to the user\'s devices.',
			// 9. Logic Nodes
			decision: 'Binary yes/no decision based on a condition.',
			switch: 'Multi-way branch based on a variable value.',
			// 10. Policy Nodes
			policy_check: 'Evaluate a policy and route based on allow/deny result.',
			// 11. Error Nodes
			error: 'Display an error screen with optional retry capability.',
			log: 'Log a message for debugging purposes.',
			// Legacy (deprecated)
			auth_method: 'Verify credentials using specified method.',
			user_input: 'Collect custom form fields from user.',
			wait_input: 'Wait for generic user input.',
			condition: 'Branch based on a condition expression.',
			check_user: 'Check user attributes (deprecated, use check_user_attribute).',
			risk_check: 'Evaluate risk score (deprecated, use check_risk).',
			set_variable: 'Set a flow variable.',
			call_api: 'Call an external API endpoint.',
			send_notification: 'Send a notification to the user.'
		};
		return descriptions[type] || 'Configure this node\'s behavior.';
	}

	function handleKeyDown(event: KeyboardEvent) {
		if (event.key === 'Escape') {
			onClose();
		}
	}

	function handleBackdropClick(event: MouseEvent) {
		if (event.target === event.currentTarget) {
			onClose();
		}
	}

	function toggleAuthMethod(method: string) {
		if (authMethods.includes(method)) {
			authMethods = authMethods.filter((m) => m !== method);
			if (authMethods.length === 0) authMethods = [method]; // At least one
		} else {
			authMethods = [...authMethods, method];
		}
		updateConfigFromForm();
	}

	function setIdentifierType(type: string) {
		identifierType = type;
		updateConfigFromForm();
	}

	function toggleMfaFactor(factor: string) {
		if (mfaFactors.includes(factor)) {
			mfaFactors = mfaFactors.filter((f) => f !== factor);
			if (mfaFactors.length === 0) mfaFactors = [factor]; // At least one
		} else {
			mfaFactors = [...mfaFactors, factor];
		}
		updateConfigFromForm();
	}

	function toggleAuthMethodSelect(method: string) {
		if (authMethodSelectMethods.includes(method)) {
			authMethodSelectMethods = authMethodSelectMethods.filter((m) => m !== method);
			if (authMethodSelectMethods.length === 0) authMethodSelectMethods = [method]; // At least one
		} else {
			authMethodSelectMethods = [...authMethodSelectMethods, method];
		}
		updateConfigFromForm();
	}

	function toggleLoginMethodSelect(method: string) {
		if (loginMethodSelectMethods.includes(method)) {
			loginMethodSelectMethods = loginMethodSelectMethods.filter((m) => m !== method);
			if (loginMethodSelectMethods.length === 0) loginMethodSelectMethods = [method]; // At least one
		} else {
			loginMethodSelectMethods = [...loginMethodSelectMethods, method];
		}
		updateConfigFromForm();
	}

	function toggleLoginMethod(method: string) {
		if (loginMethods.includes(method)) {
			loginMethods = loginMethods.filter((m) => m !== method);
			if (loginMethods.length === 0) loginMethods = [method];
		} else {
			loginMethods = [...loginMethods, method];
		}
		updateConfigFromForm();
	}

	function toggleRememberMe() {
		loginRememberMe = !loginRememberMe;
		updateConfigFromForm();
	}

	function toggleRegisterVerification() {
		registerRequireVerification = !registerRequireVerification;
		updateConfigFromForm();
	}

	function toggleRegisterAutoLogin() {
		registerAutoLogin = !registerAutoLogin;
		updateConfigFromForm();
	}

	// Predefined field templates from DB schema (user profile fields only)
	const availableFields: FieldConfig[] = [
		{ name: 'name', type: 'text', label: 'Full Name', required: false },
		{ name: 'phone', type: 'phone', label: 'Phone Number', required: false },
		{ name: 'birthdate', type: 'date', label: 'Date of Birth', required: false },
		{ name: 'gender', type: 'select', label: 'Gender', required: false },
		{ name: 'address', type: 'text', label: 'Address', required: false },
		{ name: 'company', type: 'text', label: 'Company', required: false }
	];

	// Consent types
	let consentTypes = $state<string[]>(['terms']);

	function toggleField(field: FieldConfig) {
		const existing = userInputFields.find((f) => f.name === field.name);
		if (existing) {
			userInputFields = userInputFields.filter((f) => f.name !== field.name);
		} else {
			userInputFields = [...userInputFields, { ...field }];
		}
		updateConfigFromForm();
	}

	function isFieldSelected(fieldName: string): boolean {
		return userInputFields.some((f) => f.name === fieldName);
	}

	function toggleFieldRequired(fieldName: string) {
		userInputFields = userInputFields.map((f) =>
			f.name === fieldName ? { ...f, required: !f.required } : f
		);
		updateConfigFromForm();
	}

	// Consent type options
	const availableConsents = [
		{ value: 'terms', label: 'Terms of Service' },
		{ value: 'privacy', label: 'Privacy Policy' },
		{ value: 'marketing', label: 'Marketing Communications' },
		{ value: 'data_processing', label: 'Data Processing' }
	];

	// V1 Redirect destinations (semantic)
	const availableRedirectDestinations = [
		{
			value: 'post_login',
			label: 'After Login (Dashboard)',
			description: 'Redirect after successful login'
		},
		{
			value: 'post_register',
			label: 'After Registration',
			description: 'Redirect after registration'
		},
		{ value: 'post_logout', label: 'After Logout', description: 'Redirect after logout' },
		{
			value: 'post_consent',
			label: 'After Consent',
			description: 'Redirect after consent granted'
		},
		{ value: 'return_url', label: 'Return URL', description: 'Return to originally requested URL' },
		{ value: 'error_page', label: 'Error Page', description: 'Redirect to error page' },
		{ value: 'mfa_setup', label: 'MFA Setup', description: 'Redirect to MFA setup flow' },
		{ value: 'password_reset', label: 'Password Reset', description: 'Redirect to password reset' },
		{
			value: 'account_settings',
			label: 'Account Settings',
			description: 'Redirect to account settings'
		}
	];

	// V1 Session facts (declarative)
	const availableSessionFacts = [
		{
			value: 'session.authenticated',
			label: 'Is Logged In?',
			description: 'User is authenticated'
		},
		{
			value: 'session.mfa_verified',
			label: 'MFA Verified?',
			description: 'MFA completed this session'
		},
		{ value: 'session.fresh', label: 'Session Fresh?', description: 'Recent authentication' },
		{ value: 'user.email_verified', label: 'Email Verified?', description: 'Email is verified' },
		{ value: 'user.phone_verified', label: 'Phone Verified?', description: 'Phone is verified' },
		{ value: 'user.mfa_enabled', label: 'MFA Enabled?', description: 'User has MFA set up' },
		{
			value: 'user.has_password',
			label: 'Has Password?',
			description: 'Password credential exists'
		},
		{ value: 'user.has_passkey', label: 'Has Passkey?', description: 'Passkey credential exists' },
		{ value: 'user.first_login', label: 'First Login?', description: 'This is first login' },
		{ value: 'consent.terms_accepted', label: 'Terms Accepted?', description: 'ToS accepted' },
		{ value: 'context.new_device', label: 'New Device?', description: 'Unknown device' },
		{
			value: 'context.high_risk',
			label: 'High Risk?',
			description: 'Risk score indicates high risk'
		}
	];

	// V1 Error reasons
	const availableErrorReasons = [
		{ value: 'login_failed', label: 'Login Failed' },
		{ value: 'invalid_credentials', label: 'Invalid Credentials' },
		{ value: 'account_locked', label: 'Account Locked' },
		{ value: 'account_disabled', label: 'Account Disabled' },
		{ value: 'session_expired', label: 'Session Expired' },
		{ value: 'mfa_failed', label: 'MFA Failed' },
		{ value: 'rate_limited', label: 'Rate Limited' },
		{ value: 'consent_declined', label: 'Consent Declined' },
		{ value: 'registration_failed', label: 'Registration Failed' },
		{ value: 'unknown_error', label: 'Unknown Error' }
	];

	function setRedirectTo(to: string) {
		redirectTo = to;
		updateConfigFromForm();
	}

	function setSessionFact(fact: string) {
		sessionFact = fact;
		updateConfigFromForm();
	}

	function setErrorReason(reason: string) {
		errorReason = reason;
		updateConfigFromForm();
	}

	function toggleErrorRetry() {
		errorAllowRetry = !errorAllowRetry;
		updateConfigFromForm();
	}

	function toggleConsentType(consentValue: string) {
		if (consentTypes.includes(consentValue)) {
			consentTypes = consentTypes.filter((c) => c !== consentValue);
			if (consentTypes.length === 0) consentTypes = [consentValue]; // At least one
		} else {
			consentTypes = [...consentTypes, consentValue];
		}
		updateConfigFromForm();
	}

	// Decision Node functions
	function addDecisionBranch() {
		const newBranch: DecisionBranch = {
			id: `branch_${Date.now()}`,
			label: `Branch ${decisionBranches.length + 1}`,
			condition: {
				key: 'prevNode.success',
				operator: 'isTrue'
			},
			priority: decisionBranches.length + 1
		};
		decisionBranches = [...decisionBranches, newBranch];
		updateConfigFromForm();
	}

	function removeDecisionBranch(index: number) {
		decisionBranches = decisionBranches.filter((_, i) => i !== index);
		// Re-index priorities
		decisionBranches = decisionBranches.map((b, i) => ({ ...b, priority: i + 1 }));
		updateConfigFromForm();
	}

	function updateDecisionBranch(index: number, field: keyof DecisionBranch, value: unknown) {
		decisionBranches = decisionBranches.map((b, i) =>
			i === index ? { ...b, [field]: value } : b
		);
		updateConfigFromForm();
	}

	function updateDecisionCondition(index: number, key: string, operator: string, value?: string) {
		decisionBranches = decisionBranches.map((b, i) =>
			i === index
				? {
						...b,
						condition: {
							key,
							operator,
							value: value !== undefined && value !== '' ? value : undefined
						}
					}
				: b
		);
		updateConfigFromForm();
	}

	// Switch Node functions
	function addSwitchCase() {
		const newCase: SwitchCase = {
			id: `case_${Date.now()}`,
			label: `Case ${switchCases.length + 1}`,
			values: []
		};
		switchCases = [...switchCases, newCase];
		updateConfigFromForm();
	}

	function removeSwitchCase(index: number) {
		switchCases = switchCases.filter((_, i) => i !== index);
		updateConfigFromForm();
	}

	function updateSwitchCase(index: number, field: keyof SwitchCase, value: unknown) {
		switchCases = switchCases.map((c, i) => (i === index ? { ...c, [field]: value } : c));
		updateConfigFromForm();
	}

	function updateSwitchCaseValues(index: number, valuesStr: string) {
		// Parse comma-separated values
		const values = valuesStr
			.split(',')
			.map((v) => v.trim())
			.filter((v) => v !== '');
		switchCases = switchCases.map((c, i) => (i === index ? { ...c, values } : c));
		updateConfigFromForm();
	}
</script>

{#if node}
	<!-- svelte-ignore a11y_no_noninteractive_element_interactions -->
	<div
		class="modal-backdrop"
		onclick={handleBackdropClick}
		onkeydown={handleKeyDown}
		role="dialog"
		aria-modal="true"
		aria-labelledby="modal-title"
		tabindex="-1"
	>
		<div class="modal-content">
			<div class="modal-header">
				<h3 id="modal-title">{getNodeTypeLabel(node.type)}</h3>
				<button class="close-btn" onclick={onClose} aria-label="Close">×</button>
			</div>

			<div class="modal-body">
				<p class="node-description">{getNodeDescription(node.type)}</p>

				<div class="form-group">
					<label for="node-label">Label</label>
					<input type="text" id="node-label" bind:value={label} placeholder="Enter node label" />
				</div>

				<!-- Identifier Type: Radio buttons -->
				{#if node.type === 'identifier'}
					<div class="form-group">
						<label>Identifier Type</label>
						<div class="radio-group">
							{#each ['email', 'phone', 'username'] as type (type)}
								<label class="radio-label">
									<input
										type="radio"
										name="identifier-type"
										value={type}
										checked={identifierType === type}
										onchange={() => setIdentifierType(type)}
									/>
									<span>{type.charAt(0).toUpperCase() + type.slice(1)}</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- Auth Methods: Checkboxes (multiple selection) -->
				{#if node.type === 'auth_method'}
					<div class="form-group">
						<label>Authentication Methods <span class="hint">(select one or more)</span></label>
						<div class="checkbox-group">
							{#each [{ value: 'password', label: 'Password' }, { value: 'passkey', label: 'Passkey' }, { value: 'social', label: 'Social Login' }, { value: 'magic_link', label: 'Magic Link' }] as option (option.value)}
								<label class="checkbox-label">
									<input
										type="checkbox"
										checked={authMethods.includes(option.value)}
										onchange={() => toggleAuthMethod(option.value)}
									/>
									<span>{option.label}</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- MFA Factors: Checkboxes (multiple selection) -->
				{#if node.type === 'mfa'}
					<div class="form-group">
						<label>MFA Factors <span class="hint">(select one or more)</span></label>
						<div class="checkbox-group">
							{#each [{ value: 'totp', label: 'TOTP (Authenticator App)' }, { value: 'sms', label: 'SMS' }, { value: 'email', label: 'Email OTP' }, { value: 'webauthn', label: 'WebAuthn / Passkey' }] as option (option.value)}
								<label class="checkbox-label">
									<input
										type="checkbox"
										checked={mfaFactors.includes(option.value)}
										onchange={() => toggleMfaFactor(option.value)}
									/>
									<span>{option.label}</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- Auth Method Select: Checkboxes (available methods for user to choose) -->
				{#if node.type === 'auth_method_select'}
					<div class="form-group">
						<label>Available Methods <span class="hint">(methods user can select from)</span></label>
						<div class="checkbox-group">
							{#each [{ value: 'password', label: 'Password' }, { value: 'passkey', label: 'Passkey' }, { value: 'email_otp', label: 'Email OTP' }, { value: 'sms_otp', label: 'SMS OTP' }, { value: 'magic_link', label: 'Magic Link' }, { value: 'social', label: 'Social Login' }] as option (option.value)}
								<label class="checkbox-label">
									<input
										type="checkbox"
										checked={authMethodSelectMethods.includes(option.value)}
										onchange={() => toggleAuthMethodSelect(option.value)}
									/>
									<span>{option.label}</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- Login Method Select: Checkboxes (login options for user to choose) -->
				{#if node.type === 'login_method_select'}
					<div class="form-group">
						<label>Available Methods <span class="hint">(login options user can select from)</span></label>
						<div class="checkbox-group">
							{#each [{ value: 'email', label: 'Email + Password' }, { value: 'social', label: 'Social Login' }, { value: 'passkey', label: 'Passkey' }, { value: 'enterprise', label: 'Enterprise SSO' }] as option (option.value)}
								<label class="checkbox-label">
									<input
										type="checkbox"
										checked={loginMethodSelectMethods.includes(option.value)}
										onchange={() => toggleLoginMethodSelect(option.value)}
									/>
									<span>{option.label}</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- Redirect Destination (V1 semantic) -->
				{#if node.type === 'redirect'}
					<div class="form-group">
						<label>Redirect To <span class="hint">(semantic destination)</span></label>
						<div class="radio-group">
							{#each availableRedirectDestinations as dest (dest.value)}
								<label class="radio-label">
									<input
										type="radio"
										name="redirect-to"
										value={dest.value}
										checked={redirectTo === dest.value}
										onchange={() => setRedirectTo(dest.value)}
									/>
									<span class="option-content">
										<span class="option-label">{dest.label}</span>
										<span class="option-description">{dest.description}</span>
									</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- Check Session (V1 fact-based) -->
				{#if node.type === 'check_session'}
					<div class="form-group">
						<label>Session Fact <span class="hint">(condition to check)</span></label>
						<div class="radio-group">
							{#each availableSessionFacts as fact (fact.value)}
								<label class="radio-label">
									<input
										type="radio"
										name="session-fact"
										value={fact.value}
										checked={sessionFact === fact.value}
										onchange={() => setSessionFact(fact.value)}
									/>
									<span class="option-content">
										<span class="option-label">{fact.label}</span>
										<span class="option-description">{fact.description}</span>
									</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- Error Screen (V1) -->
				{#if node.type === 'error'}
					<div class="form-group">
						<label>Error Reason</label>
						<div class="radio-group compact">
							{#each availableErrorReasons as reason (reason.value)}
								<label class="radio-label">
									<input
										type="radio"
										name="error-reason"
										value={reason.value}
										checked={errorReason === reason.value}
										onchange={() => setErrorReason(reason.value)}
									/>
									<span>{reason.label}</span>
								</label>
							{/each}
						</div>
					</div>
					<div class="form-group">
						<label class="checkbox-label single">
							<input type="checkbox" checked={errorAllowRetry} onchange={toggleErrorRetry} />
							<span>Allow Retry (shows retry button)</span>
						</label>
					</div>
				{/if}

				<!-- Login Methods: Checkboxes + Remember Me -->
				{#if node.type === 'login'}
					<div class="form-group">
						<label>Login Methods <span class="hint">(select one or more)</span></label>
						<div class="checkbox-group">
							{#each [{ value: 'password', label: 'Password' }, { value: 'passkey', label: 'Passkey' }, { value: 'social', label: 'Social Login' }, { value: 'magic_link', label: 'Magic Link' }] as option (option.value)}
								<label class="checkbox-label">
									<input
										type="checkbox"
										checked={loginMethods.includes(option.value)}
										onchange={() => toggleLoginMethod(option.value)}
									/>
									<span>{option.label}</span>
								</label>
							{/each}
						</div>
					</div>
					<div class="form-group">
						<label class="checkbox-label single">
							<input type="checkbox" checked={loginRememberMe} onchange={toggleRememberMe} />
							<span>Remember Me option</span>
						</label>
					</div>
				{/if}

				<!-- Register Options -->
				{#if node.type === 'register'}
					<div class="form-group">
						<label>Registration Options</label>
						<div class="checkbox-group">
							<label class="checkbox-label">
								<input
									type="checkbox"
									checked={registerRequireVerification}
									onchange={toggleRegisterVerification}
								/>
								<span>Require Email Verification</span>
							</label>
							<label class="checkbox-label">
								<input
									type="checkbox"
									checked={registerAutoLogin}
									onchange={toggleRegisterAutoLogin}
								/>
								<span>Auto-login after registration</span>
							</label>
						</div>
					</div>
				{/if}

				<!-- Consent Types -->
				{#if node.type === 'consent'}
					<div class="form-group">
						<label>Consent Types <span class="hint">(select one or more)</span></label>
						<div class="checkbox-group">
							{#each availableConsents as consent (consent.value)}
								<label class="checkbox-label">
									<input
										type="checkbox"
										checked={consentTypes.includes(consent.value)}
										onchange={() => toggleConsentType(consent.value)}
									/>
									<span>{consent.label}</span>
								</label>
							{/each}
						</div>
					</div>
				{/if}

				<!-- User Input Fields -->
				{#if node.type === 'user_input'}
					<div class="form-group">
						<label>Fields to Collect <span class="hint">(select from DB schema)</span></label>
						<div class="field-selector">
							{#each availableFields as field (field.name)}
								<div class="field-item" class:selected={isFieldSelected(field.name)}>
									<label class="field-checkbox">
										<input
											type="checkbox"
											checked={isFieldSelected(field.name)}
											onchange={() => toggleField(field)}
										/>
										<span class="field-label">{field.label}</span>
										<span class="field-type">{field.type}</span>
									</label>
									{#if isFieldSelected(field.name)}
										<label class="required-toggle">
											<input
												type="checkbox"
												checked={userInputFields.find((f) => f.name === field.name)?.required}
												onchange={() => toggleFieldRequired(field.name)}
											/>
											<span>Required</span>
										</label>
									{/if}
								</div>
							{/each}
						</div>
						{#if userInputFields.length > 0}
							<div class="selected-fields">
								<span class="hint"
									>Selected: {userInputFields.map((f) => f.label || f.name).join(', ')}</span
								>
							</div>
						{/if}
					</div>
				{/if}

				<!-- Collapsible JSON Config -->
				<div class="json-section">
					<button class="json-toggle" onclick={() => (jsonExpanded = !jsonExpanded)} type="button">
						<span class="toggle-icon">{jsonExpanded ? '▼' : '▶'}</span>
						<span>Advanced (JSON)</span>
					</button>

					{#if jsonExpanded}
						<div class="json-content">
							<textarea
								id="node-config"
								bind:value={configJson}
								rows="6"
								class:has-error={!!configError}
								spellcheck="false"
							></textarea>
							{#if configError}
								<span class="error-text">{configError}</span>
							{/if}
						</div>
					{/if}
				</div>
			</div>

			<div class="modal-footer">
				{#if onDelete && canDelete(node.type)}
					<button class="btn-delete" onclick={handleDelete}>Delete</button>
				{/if}
				<div class="footer-right">
					<button class="btn-secondary" onclick={onClose}>Cancel</button>
					<button class="btn-primary" onclick={handleSave}>Save</button>
				</div>
			</div>
		</div>
	</div>
{/if}

<style>
	.modal-backdrop {
		position: fixed;
		inset: 0;
		background: rgba(0, 0, 0, 0.4);
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: 1000;
	}

	.modal-content {
		background: white;
		border-radius: 8px;
		width: 420px;
		max-width: 90vw;
		max-height: 90vh;
		display: flex;
		flex-direction: column;
		box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
	}

	.modal-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 12px 16px;
		border-bottom: 1px solid #e5e7eb;
	}

	.modal-header h3 {
		margin: 0;
		font-size: 14px;
		font-weight: 600;
		color: #111827;
	}

	.close-btn {
		width: 28px;
		height: 28px;
		display: flex;
		align-items: center;
		justify-content: center;
		background: transparent;
		border: none;
		border-radius: 4px;
		font-size: 20px;
		color: #6b7280;
		cursor: pointer;
	}

	.close-btn:hover {
		background: #f3f4f6;
		color: #111827;
	}

	.modal-body {
		padding: 16px;
		overflow-y: auto;
	}

	.node-description {
		margin: 0 0 16px 0;
		padding: 12px;
		background: #f8fafc;
		border-radius: 6px;
		font-size: 13px;
		color: #475569;
		line-height: 1.5;
	}

	.form-group {
		margin-bottom: 16px;
	}

	.form-group:last-child {
		margin-bottom: 0;
	}

	.form-group > label {
		display: block;
		font-size: 12px;
		font-weight: 500;
		color: #374151;
		margin-bottom: 6px;
	}

	.form-group > label .hint {
		font-weight: 400;
		color: #9ca3af;
	}

	.form-group input[type='text'] {
		width: 100%;
		padding: 8px 10px;
		border: 1px solid #d1d5db;
		border-radius: 6px;
		font-size: 13px;
		font-family: inherit;
	}

	.form-group input[type='text']:focus {
		outline: none;
		border-color: #2563eb;
		box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
	}

	/* Radio group */
	.radio-group {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	.radio-label {
		display: flex;
		align-items: center;
		gap: 8px;
		padding: 8px 12px;
		background: #f9fafb;
		border: 1px solid #e5e7eb;
		border-radius: 6px;
		cursor: pointer;
		font-size: 13px;
		color: #374151;
		transition: all 0.15s;
	}

	.radio-label:hover {
		background: #f3f4f6;
		border-color: #d1d5db;
	}

	.radio-label:has(input:checked) {
		background: #eff6ff;
		border-color: #2563eb;
		color: #1d4ed8;
	}

	.radio-label input[type='radio'] {
		accent-color: #2563eb;
	}

	/* Option content with label + description */
	.option-content {
		display: flex;
		flex-direction: column;
		gap: 2px;
	}

	.option-label {
		font-weight: 500;
	}

	.option-description {
		font-size: 10px;
		color: #6b7280;
		font-weight: 400;
	}

	.radio-label:has(input:checked) .option-description {
		color: #60a5fa;
	}

	/* Compact radio group (for error reasons) */
	.radio-group.compact {
		display: grid;
		grid-template-columns: 1fr 1fr;
		gap: 6px;
	}

	.radio-group.compact .radio-label {
		padding: 6px 10px;
		font-size: 12px;
	}

	/* Checkbox group */
	.checkbox-group {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	.checkbox-label {
		display: flex;
		align-items: center;
		gap: 8px;
		padding: 8px 12px;
		background: #f9fafb;
		border: 1px solid #e5e7eb;
		border-radius: 6px;
		cursor: pointer;
		font-size: 13px;
		color: #374151;
		transition: all 0.15s;
	}

	.checkbox-label:hover {
		background: #f3f4f6;
		border-color: #d1d5db;
	}

	.checkbox-label:has(input:checked) {
		background: #eff6ff;
		border-color: #2563eb;
		color: #1d4ed8;
	}

	.checkbox-label input[type='checkbox'] {
		accent-color: #2563eb;
	}

	/* JSON section */
	.json-section {
		margin-top: 16px;
		border-top: 1px solid #e5e7eb;
		padding-top: 12px;
	}

	.json-toggle {
		display: flex;
		align-items: center;
		gap: 6px;
		background: none;
		border: none;
		padding: 4px 0;
		font-size: 12px;
		color: #6b7280;
		cursor: pointer;
	}

	.json-toggle:hover {
		color: #374151;
	}

	.toggle-icon {
		font-size: 10px;
		width: 12px;
	}

	.json-content {
		margin-top: 8px;
	}

	.json-content textarea {
		width: 100%;
		padding: 8px 10px;
		border: 1px solid #d1d5db;
		border-radius: 6px;
		font-family: ui-monospace, SFMono-Regular, monospace;
		font-size: 11px;
		line-height: 1.5;
		resize: vertical;
	}

	.json-content textarea:focus {
		outline: none;
		border-color: #2563eb;
		box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
	}

	.json-content textarea.has-error {
		border-color: #ef4444;
	}

	.error-text {
		display: block;
		margin-top: 4px;
		font-size: 11px;
		color: #ef4444;
	}

	.modal-footer {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 12px 16px;
		border-top: 1px solid #e5e7eb;
		gap: 8px;
	}

	.footer-right {
		display: flex;
		gap: 8px;
		margin-left: auto;
	}

	.btn-primary {
		padding: 6px 14px;
		background-color: #2563eb;
		color: white;
		border: none;
		border-radius: 6px;
		font-size: 13px;
		cursor: pointer;
	}

	.btn-primary:hover {
		background-color: #1d4ed8;
	}

	.btn-secondary {
		padding: 6px 14px;
		background-color: white;
		color: #374151;
		border: 1px solid #d1d5db;
		border-radius: 6px;
		font-size: 13px;
		cursor: pointer;
	}

	.btn-secondary:hover {
		background-color: #f3f4f6;
	}

	.btn-delete {
		padding: 6px 14px;
		background: white;
		border: 1px solid #fecaca;
		border-radius: 6px;
		color: #dc2626;
		font-size: 13px;
		cursor: pointer;
	}

	.btn-delete:hover {
		background: #fef2f2;
	}

	/* Single checkbox (not in group) */
	.checkbox-label.single {
		margin-top: 8px;
	}

	/* Field selector for User Input */
	.field-selector {
		display: flex;
		flex-direction: column;
		gap: 6px;
	}

	.field-item {
		display: flex;
		align-items: center;
		justify-content: space-between;
		padding: 8px 12px;
		background: #f9fafb;
		border: 1px solid #e5e7eb;
		border-radius: 6px;
		transition: all 0.15s;
	}

	.field-item:hover {
		background: #f3f4f6;
		border-color: #d1d5db;
	}

	.field-item.selected {
		background: #eff6ff;
		border-color: #2563eb;
	}

	.field-checkbox {
		display: flex;
		align-items: center;
		gap: 8px;
		cursor: pointer;
		flex: 1;
	}

	.field-checkbox input[type='checkbox'] {
		accent-color: #2563eb;
	}

	.field-label {
		font-size: 13px;
		color: #374151;
	}

	.field-type {
		font-size: 10px;
		color: #9ca3af;
		background: #e5e7eb;
		padding: 1px 6px;
		border-radius: 3px;
		margin-left: 8px;
	}

	.required-toggle {
		display: flex;
		align-items: center;
		gap: 4px;
		font-size: 11px;
		color: #6b7280;
		cursor: pointer;
	}

	.required-toggle input[type='checkbox'] {
		accent-color: #2563eb;
	}

	.selected-fields {
		margin-top: 8px;
	}

	.selected-fields .hint {
		font-size: 11px;
		color: #6b7280;
	}
</style>
