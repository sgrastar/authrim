import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdirSync, rmSync, existsSync, readFileSync, writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { tmpdir } from 'node:os';
import {
  generateUiEnvContent,
  saveUiEnv,
  copyUiEnvToPackage,
  cleanupPackageEnv,
  uiEnvExists,
} from '../core/ui-env.js';

describe('ui-env module', () => {
  let testDir: string;

  beforeEach(() => {
    testDir = join(
      tmpdir(),
      `authrim-ui-env-test-${Date.now()}-${Math.random().toString(36).slice(2)}`
    );
    mkdirSync(testDir, { recursive: true });
  });

  afterEach(() => {
    if (existsSync(testDir)) {
      rmSync(testDir, { recursive: true, force: true });
    }
  });

  describe('generateUiEnvContent', () => {
    it('should generate valid .env content', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://prod-ar-router.workers.dev',
      });

      expect(content).toContain('# Auto-generated by @authrim/setup');
      expect(content).toContain('PUBLIC_API_BASE_URL=https://prod-ar-router.workers.dev');
      expect(content).toMatch(/\n$/); // Should end with newline
    });

    it('should skip empty values', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: '',
      });

      expect(content).not.toContain('PUBLIC_API_BASE_URL=');
    });

    it('should include comment header', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://example.com',
      });

      expect(content).toContain('# Auto-generated by @authrim/setup');
      expect(content).toContain('# Do not edit manually');
    });

    it('should handle URLs with special characters', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://my-env-ar-router.my-subdomain.workers.dev',
      });

      expect(content).toContain(
        'PUBLIC_API_BASE_URL=https://my-env-ar-router.my-subdomain.workers.dev'
      );
    });

    it('should quote values containing spaces', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://example.com/path with spaces',
      });

      expect(content).toContain('PUBLIC_API_BASE_URL="https://example.com/path with spaces"');
    });

    it('should quote values containing hash (#)', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://example.com/path#anchor',
      });

      expect(content).toContain('PUBLIC_API_BASE_URL="https://example.com/path#anchor"');
    });

    it('should escape double quotes in values', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://example.com/path"quoted"',
      });

      expect(content).toContain('PUBLIC_API_BASE_URL="https://example.com/path\\"quoted\\""');
    });

    it('should escape backslashes in values', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://example.com/path\\with\\backslash',
      });

      expect(content).toContain(
        'PUBLIC_API_BASE_URL="https://example.com/path\\\\with\\\\backslash"'
      );
    });

    it('should not quote simple URLs without special characters', () => {
      const content = generateUiEnvContent({
        PUBLIC_API_BASE_URL: 'https://example.com/simple-path',
      });

      // Should NOT have quotes around the value
      expect(content).toContain('PUBLIC_API_BASE_URL=https://example.com/simple-path');
      expect(content).not.toContain('"https://example.com/simple-path"');
    });
  });

  describe('saveUiEnv', () => {
    it('should create ui.env file with correct content', async () => {
      const envPath = join(testDir, 'ui.env');

      await saveUiEnv(envPath, {
        PUBLIC_API_BASE_URL: 'https://test-ar-router.workers.dev',
      });

      expect(existsSync(envPath)).toBe(true);
      const content = readFileSync(envPath, 'utf-8');
      expect(content).toContain('PUBLIC_API_BASE_URL=https://test-ar-router.workers.dev');
    });

    it('should create parent directories if they do not exist', async () => {
      const envPath = join(testDir, 'nested', 'dir', 'ui.env');

      await saveUiEnv(envPath, {
        PUBLIC_API_BASE_URL: 'https://example.com',
      });

      expect(existsSync(envPath)).toBe(true);
    });

    it('should overwrite existing file', async () => {
      const envPath = join(testDir, 'ui.env');

      // Create initial file
      await saveUiEnv(envPath, {
        PUBLIC_API_BASE_URL: 'https://old-url.com',
      });

      // Overwrite
      await saveUiEnv(envPath, {
        PUBLIC_API_BASE_URL: 'https://new-url.com',
      });

      const content = readFileSync(envPath, 'utf-8');
      expect(content).toContain('PUBLIC_API_BASE_URL=https://new-url.com');
      expect(content).not.toContain('https://old-url.com');
    });
  });

  describe('copyUiEnvToPackage', () => {
    it('should copy ui.env to package .env', async () => {
      // Create source ui.env
      const sourceDir = join(testDir, 'source');
      const packageDir = join(testDir, 'package');
      mkdirSync(sourceDir, { recursive: true });
      mkdirSync(packageDir, { recursive: true });

      const sourcePath = join(sourceDir, 'ui.env');
      writeFileSync(sourcePath, 'PUBLIC_API_BASE_URL=https://test.com\n');

      await copyUiEnvToPackage(sourcePath, packageDir);

      const targetPath = join(packageDir, '.env');
      expect(existsSync(targetPath)).toBe(true);
      const content = readFileSync(targetPath, 'utf-8');
      expect(content).toBe('PUBLIC_API_BASE_URL=https://test.com\n');
    });

    it('should overwrite existing .env in package', async () => {
      const sourceDir = join(testDir, 'source');
      const packageDir = join(testDir, 'package');
      mkdirSync(sourceDir, { recursive: true });
      mkdirSync(packageDir, { recursive: true });

      // Create existing .env in package
      writeFileSync(join(packageDir, '.env'), 'OLD_VAR=old_value\n');

      // Create source ui.env
      const sourcePath = join(sourceDir, 'ui.env');
      writeFileSync(sourcePath, 'PUBLIC_API_BASE_URL=https://new-test.com\n');

      await copyUiEnvToPackage(sourcePath, packageDir);

      const content = readFileSync(join(packageDir, '.env'), 'utf-8');
      expect(content).toBe('PUBLIC_API_BASE_URL=https://new-test.com\n');
      expect(content).not.toContain('OLD_VAR');
    });

    it('should throw if source file does not exist', async () => {
      const packageDir = join(testDir, 'package');
      mkdirSync(packageDir, { recursive: true });

      await expect(
        copyUiEnvToPackage(join(testDir, 'nonexistent.env'), packageDir)
      ).rejects.toThrow();
    });
  });

  describe('cleanupPackageEnv', () => {
    it('should delete .env from package directory', async () => {
      const packageDir = join(testDir, 'package');
      mkdirSync(packageDir, { recursive: true });
      const envPath = join(packageDir, '.env');
      writeFileSync(envPath, 'TEST=value\n');

      expect(existsSync(envPath)).toBe(true);

      await cleanupPackageEnv(packageDir);

      expect(existsSync(envPath)).toBe(false);
    });

    it('should not throw if .env does not exist', async () => {
      const packageDir = join(testDir, 'package');
      mkdirSync(packageDir, { recursive: true });

      // Should not throw
      await expect(cleanupPackageEnv(packageDir)).resolves.not.toThrow();
    });

    it('should not affect other files in package directory', async () => {
      const packageDir = join(testDir, 'package');
      mkdirSync(packageDir, { recursive: true });
      writeFileSync(join(packageDir, '.env'), 'TEST=value\n');
      writeFileSync(join(packageDir, 'package.json'), '{}');

      await cleanupPackageEnv(packageDir);

      expect(existsSync(join(packageDir, '.env'))).toBe(false);
      expect(existsSync(join(packageDir, 'package.json'))).toBe(true);
    });
  });

  describe('uiEnvExists', () => {
    it('should return true if ui.env exists', async () => {
      const envPath = join(testDir, 'ui.env');
      writeFileSync(envPath, 'PUBLIC_API_BASE_URL=https://test.com\n');

      const exists = await uiEnvExists(envPath);

      expect(exists).toBe(true);
    });

    it('should return false if ui.env does not exist', async () => {
      const envPath = join(testDir, 'nonexistent.env');

      const exists = await uiEnvExists(envPath);

      expect(exists).toBe(false);
    });

    it('should return false for directory path', async () => {
      const dirPath = join(testDir, 'dir');
      mkdirSync(dirPath, { recursive: true });

      // This should return false because it's a directory, not a file
      // Note: access() returns true for directories with F_OK
      // But we're checking for file existence, so this behavior is acceptable
      const exists = await uiEnvExists(dirPath);

      // access() with F_OK returns true for directories too
      // This is expected behavior - we're just checking if the path exists
      expect(typeof exists).toBe('boolean');
    });
  });

  describe('integration: save, copy, cleanup flow', () => {
    it('should complete full workflow: save ui.env, copy to package, cleanup', async () => {
      // Setup directories
      const envDir = join(testDir, '.authrim', 'prod');
      const packageDir = join(testDir, 'packages', 'ar-admin-ui');
      mkdirSync(envDir, { recursive: true });
      mkdirSync(packageDir, { recursive: true });

      const uiEnvPath = join(envDir, 'ui.env');
      const packageEnvPath = join(packageDir, '.env');

      // Step 1: Save ui.env (simulates init command)
      await saveUiEnv(uiEnvPath, {
        PUBLIC_API_BASE_URL: 'https://prod-ar-router.workers.dev',
      });
      expect(existsSync(uiEnvPath)).toBe(true);

      // Step 2: Copy to package (simulates deploy command before build)
      await copyUiEnvToPackage(uiEnvPath, packageDir);
      expect(existsSync(packageEnvPath)).toBe(true);
      expect(readFileSync(packageEnvPath, 'utf-8')).toContain('prod-ar-router');

      // Step 3: Cleanup (simulates deploy command after build)
      await cleanupPackageEnv(packageDir);
      expect(existsSync(packageEnvPath)).toBe(false);

      // Step 4: Original ui.env should still exist
      expect(existsSync(uiEnvPath)).toBe(true);
    });
  });
});
